내 IP주소 : 220.126.70.201


SQL : STRUCTURED QUERY LANGUAGE. 관리형 데이터베이스 관리 시스템을 위한 프로그래밍 언어

QUERY : 쿼리 또는 질의. 데이터베이스에 정보를 요청하는 것.

DB : DATABASE. 체계화된 데이터의 모임. 여러 응용 시스템들의 통합된 정보들을 저장하여 운영할 수 있는 공용 데이터들의 묶음. 데이터가 실질적으로 적재되는 테이블들을 분류하는 상위 개념.
	-> 장점 : 실시간 접속 및 업데이트 가능, 동시 공유 가능, 데이터 중복의 최소화, 공유, 일관성, 		무결성, 보안성 유지, 용이한 데이터 접근, 데이터 저장공간 절약
	-> 단점 : 데이터베이스 전문가가 필요, 많은 비용 부담, 데이터의 백업과 복구가 어려움, 대용			량 액세스가 집중되면 과부화 발생

	생성 - CREATE DATABASE `데이터베이스명`
	삭제 - DROP DATEBASE `데이터베이스명`
	열람 - SHOW DATABASES; 모든 데이터베이스 나열
	선택 - USE `데이터베이스명` 해당 데이터베이스 안으로 들어가기

관계형 데이터베이스(RALATIONAL DATABASE) : 키(KEY)와 값들의 간단한 관계로 테이블화 시킨 매우 원칙적인 데이터 베이스.
	이 모델에서는 데이터를 컬럼과 로우를 이루는 하나 이상의 테이블로 정리하며, 고유 		키(PRIMARY KEY)가 각 로우를 식별한다. 

	키(KEY) - 테이블의 각 로우에는 저만의 고유 키가 존재한다. 한 테이블 안의 로우는 다른 테	이블들의 로우로 연결이 가능한데, 이는 연결된 로우의 고유 키를 위한 컬럼을 추가함으로써 	이루어진다.

TABLE : 데이터가 실질적으로 저장되는 저장소
	스키마(SCHEMA) : 적재될 데이터의 구조과 형식을 정의

	생성 CREATE TABLE 테이블명 ( 칼럼명1 데이터타입, 칼럼명2 데이터타입, ...)
	열람 SHOW TABLES;
	스키마 열람 DESC `테이블명`
	테이블 제거 DROP TABLE `테이블명`

DBMS : 데이터베이스 관리 시스템. 데이터 베이스 내의 데이터를 접근할 수 있도록 해주는 소프트웨어 도구의 집합. 사용자 또는 다른 프로그램의 요구를 처리하고 적절히 응답하여 데이터를 사용할 수 있도록 해준다.
	데이터에 대한 정의, 데이터베이스 구축, 조작, 공유, 보호, 유지보수 등의 기능을 한다.

DB -> 관리하는 시스템이 DBMS -> DBMS에서 사용하는 프로그래밍 언어가 SQL

DBMS 언어
	
	데이터 정의 언어(DDL : DATA DEFINITION LANGUAGE)
		CREATE - 데이터베이스에 객체(테이블)을 생성
		ALTER - 현존하는 객체의 구조를 변경. 테이블의 컬럼을 추가하거나 제한을 추가
		TRUNCATE - 테이블 내의 모든 데이터를 빠르게 삭제.
		DROP - 데이터베이스에서 객체를 삭제.
		
	데이터 조작 언어(DML : DATA MANIPULATION LANGUAGE)
		INSERT INTO - 행 데이터 또는 테이블 데이터의 삽입
		INSERT INTO 테이블명(`칼럼1`, `칼럼2`) VALUES(값1, 값2)
		-> 칼럼수와 타입이 같다면 테이블명 뒤의 칼럼에 대한 서술을 생략해도 된다.

		UPDATE ~ SET - 표 업데이트
		UPDATE 테이블명 SET 컬럼1=컬럼1의 값, 컬럼2=컬럼2의값 WHERE 대상이 될 컬		럼명 = 컬럼의 값		

		DELETE FROM - 테이블에서 특정 행의 삭제. WHERE로 특정 행을 지정하지 않으면 			테이블 내의 데이터를 전체 삭제한다. = TRUNCATE

		*****SELECT ~ FROM - 테이블 데이터의 검색 결과 집합의 취득(데이터의 조회)

		SELECT 칼럼명
		FROM 테이블명
		[WHERE 조건절] - 데이터 취합 이전에 필요한 테이블을 수취한다.
		[GROUP BY 칼럼명]
		[HAVING 조건절] - 데이터 취합한 이후 필요한 부분만 수취한다.
		[ORDER BY 칼럼명 [ASC|DESC]]
		[LIMIT OFFSET,조회 할 행의 수]
		

	데이터 제어 언어(DCL ; DATA CONTROL LANGUAGE) -> ?
		GRANT - 특정 데이터베이스 사용자에게 특정 작업의 수행 권한을 부여
		GRANT 권한 ON 데이터베이스.테이블 TO '아이디'@'호스트' IDENTIFIED MY '비번'
		SHOW GRANTS FOR 사용자 - 권한 열람

		REVOKE - 특정 데이터베이스 이용자로부터 이미 준 권한을 박탈
		REVOKE 권한 ON 테이터베이스.테이블 FROM 사용자

		DROP USER 유저명 - 사용자 삭제	
	
		SET TRANSACTION - 트랜젝션 모드 설정.
		BEGIN - 트랜젝션 시작
		COMMIT - 트랜젝션 실행
		ROLLBACK - 트랜젝션 취소
		SAVEPOINT - 무작위로 롤백 지점을 설정
		LOCK - 표 등의 자원을 차지

자료형 (DATA TYPE)
	
	문자열 
		CHAR(N) - 고정폭 N문자열
		VARCHAR(N) - 가변폭 문자열(최대 크기가 N)
		NCHAR, NVARCHAR - 국제 문자셋을 지원하는 문자열
		TINYTEXT, TEXT
	비트열
		BIT(N) - N비트의 배열
		BIT VARYING(N) - N비트까지의 배열
	수
		TINYINT, SMALLINT, INT - 정수
		FLOAT, REAL, DOUBLE PRECISION - 부동소수점
		NUMBER(PRECISION, SCALE) /F DECIMAL(PRECISION, SCALE)

	날짜와 시간
		DATE : 날짜 값. YYYY-MM-DD
		TIME : 시간 값. HH:MM:SS
		TIMESTAMP : DATE와 TIME을 하나의 변수로 결합. YYYY-MM-DD HH:MM:SS

키(KEY / INDEX) : 인덱스는 원하는 데이터를 쉽게 찾을 수 있도록 돕는 색인과 유사한 개념이다.
	테이블을 기반으로 선택적으로 생성할 수 있는 구조이다.
	기본적인 목적은 검색 성능의 최적화이다.
	DML 작업시에는 테이블상에 인덱스를 같이 변경하므로 느려지는 단점이 존재한다.

	PRIMARY : 중복이 허용되지 않는 유일한 키. 한 테이블당 한컬럼만 존재 가능
	NORMAL : 중복을 허용하는 인덱스
	UNIQUE : 중복을 허용하지 않는 유일한 키
	FOREIGN : 다른 테이블과의 관계성을 부여하는 키

NULL : 아무 값도 없다. 연산이 불가능함. NULL과 연산시 NULL이 리턴됨. 공백 혹은 0과 다름.
	NULL값을 조회하기 위해선 IS NULL을 이용. NULL값이 아닌 값을 조회하기 위해서는 IS NOT 	NULL을 사용. -> NULL관련 함수 참조


//////////////////////////////////////////////////////////////////////////////////////////////////////////////

*****SELECT 문

	알고싶은 것 -> 열의 이름(SELECT)
	알고싶은 내용의 정보가 존재하는 곳 -> 테이블명(FROM)
	조건 -> 부가적인 내용(WHERE, GROUP BY, HAVING, ORDER BY)

	1) SELECT 칼럼명 [ALIAS] -> 출력 및 계산
	2) FROM 테이블명
	3) WHERE 조건식 -> 검색 대상에 대한(검색전)
	4) GROUP BY 컬럼이나 표현식 
	5) HAVING 그룹 조건식 -> 검색 결과에 대한
	6) ORDER BY 칼럼이나 표현식 -> 정렬
	[7) LIMIL OFFSET, 조회할 행의 수]

	옵티마이저가 SQL문장의 SNYTAX, SEMANTIC 에러를 점검하는 순서이자 실행 순서
	1. 발췌 대상 테이블을 참조한다.(FROM)
	2. 발췌 대상 데이터가 아닌 것을 제거한다.(WHERE)
	3. 행들을 소그룹화 한다.(GROUP BY)
	4. 그룹핑된 값의 조건에 맞는 것만을 출력한다.(HAVING)
	5. 데이터 값을 출력 및 계산한다.(SELECT)
	6. 데이터를 정렬한다.(ORDER BY)
	
	-> FROM 절에 정의되지 않은 테이블의 컬럼을 다른 절에서 사용하게 되면 에러가 난다. 그러		나 ORDER BY 절에는 SELECT 목록에 나타나지 않은 문자형 항목기 포함될 수 있다.

	1) SELECT
	데이터의 조회. 다른 말로 QUERY라고도 함. 테이블 상의 필요한 데이터를 조회하기 위한 언	어.
		ALIAS : 별명 부여. -> AS를 이용하여 별명을 부여. (생략 가능)
		이중 인용부호""를 사용하는 경우 -> 별명에 공백, 특수문자, 대소문자 구분이 필요		한 경우
		ALL : DEFAULT 옵션으로 별도의 표시를 하지 않으면 중복된 데이터 포함 모든 데이			터를 출력한다.
		DISTINCT : 중복된 데이터가 있는 경우 1건으로 처리해서 출력한다. 

	3) WHERE 
	자신이 원하는 자료만을 검색하기 위해서 SQL문장에서 WHERE 조건을 이용하여 자료들에 대		해 제한 할 수 있다. 조건이 없는 SELECT문은 테이블 전체를 읽게 되어 데이터 양에 따라 성	능을 저하시킨다.

		구성 : 칼럼명(조건식의 좌측에 위치), 연산자, 문자 및 숫자 표현식(조건식의 우				측), 비교컬럼명(JOIN 사용시)

		비교 연산자 : 숫자 및 문자의 대소를 비교해 준다.
		-> 문자 유형의 대소 비교 : 모두 CHAR인 경우, 길이가 다르면 한쪽에 SPACE를 추		가 한 뒤 서로 다른 문자가 나올때 까지 비교. 달라진 첫 문자의 값에 따라 크기를 		비교한다. 한쪽이 VARCHAR인 경우, 길이가 다르면 길이가 긴 것이 크다고 판단한		다.
	
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
* 연산자의 종류
	산술 연산자 - 조건절 또는 SELECT 하는 위치에서 수치의 계산 일반적으로 산술 연산을 사용	하거나 특정 함수를 적용하게 되면 칼럼의 라벨이 길어지게 되므로 적절한 ALIAS를 부여하는 	것이 좋다.
		+, -, *, /, ()
	연결(합성) 연산자 - 서로 다른 두개의 문자열을 연결한다.
		* 혹은 CONCAT(칼럼1, 칼럼2) '문자열'도 사용 가능
	비교 연산자 - WHERE 조건절에서 범위를 지정할 때 사용
		=, !=(<>), <, >, <=, >=
	IS NULL - 존재하지 않는 확정되지 않은 값을 표현할 때 사용하며 비교연산자와 비교 자체가 		불가능하다. NULL은 수치연산시 NULL을 리턴, 비교연산시 FALSE를 리턴.
	
	논리 연산자 - 여러 조건절들을 논리적으로 연결
		AND, OR, NOT
	범위 검색 
		WHERE 컬럼명 BETWEEN 범위의 하한값(포함) AND 범위의 상한값(포함)
	대상 지정 검색
		WHERE 칼럼명 IN(특정값1, 특정값2) -> OR 과 같다.
	문자열 검색 - 부분적으로 일치하는 문자열의 검색
		LIKE('문자열') -> %는 자릿수에 상관없이 사용, _는 자릿수가 정해진 경우
	우선순위
		(	) -> NOT -> 비교연산자 -> AND -> OR

	집합 연산자 - 두개 이상의 집합(SELECT의 결과) 에 대해서 서로 더하거나 빼는 등의 연산을 		수행. 합친 후 정렬은 ORDER BY절을 사용한다.
		UNION : 두 집합을 하나로 합치고, 중복행은 한번만 출력
		UNION ALL : 두 집합을 하나로 합치고, 중복을 그대로 표시
		INTERSECTION : 교집합을 출력하되, 중복행은 한번만 출력
		EXCEPT : 첫 집합의 결과에서 두번째 집합의 결과는 제외. 중복은 한번만 출력
		PRODUCT : CROSS PRUDUCT라 불리는 곱집합.
		-> 테이블에서 추출하는 컬럼의 수와 데이터 타입이 일치해야 사용가능.

	순수 관계형 연산자 - 관계형 데이터베이스를 구현하기 위해 새롭게 만들어진 연산자
		SELECT - WHERE 절로 구현 (행으로 데이터 추출)
		PROJECT - SELECT 절로 구현 (열로 데이터 추출)
		(NATURAL) JOIN - 다양한 JOIN으로 구현. WHERE 절의 INNER JOIN조건과 함께 			FROM 절의 NATURAL JOIN, INNER JOIN, OUTER JOIN, USING 조건절, ON 조건절 			등
		DIVIDE - 현재는 새용되지 않음.
	
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////


	4) GROUP BY ~ HAVING
	지정컬럼의 데이터들 중에서 동일한 데이터를 묶어 여러 집계 작업을 수행
	WINDOW FUNCTION의 PARTITION BY와 유사하다.

	SELECT 집계 기준 컬럼명1, 집계 기준 컬럼명2, 집계함수(일반컬럼)

	집계 함수 : SELECT절, HAVING절, ORDER BY절에서 사용할 수있다. -> 집계함수 참조
		COUNT(*) - NULL을 포함한 행의 수를 출력
		COUNT(표현식) - NULL값을 제외한 행의 수를 출력
		SUM, AVG, MIN, STDDEV(표준편차), VARIAN(분산)

	HAVING -> GROUP BY 된 결과 중에서 조건에 부합되는 데이터만 출력

	6) ORDER BY
	ORDER BY 절은 SQL문장으로 조회된 데이터들을 다양한 목적에 맞게 특정 칼럼을 기준으로 		정렬하여 출력하는데 사용한다. ORDER BY 절에 컬럼 명 대신 SELECT절에서 사용한 ALIAS 명		이나 칼럼 순서를 나타내는 정수도 사용 가능하다. 별도의 정렬 방식을 지정하지 않으면 기본		적으로 오름차순(ASC)이 적용되며 SQL문장의 가장 지막에 위치한다.

	* GROUP BY 절에서 그룹핑 기준을 정의하게 되면 데이터베이스를 일반적으로 SELECT 문장	처럼 FROM 절에서 정의된 테이블의 구조를 그대로 가져가는 것이 아니라, 그룹핑 기준에 사	용된 컬럼과 집계 함수에 사용될 수 있는 숫자형 데이터 칼럼들의 집합을 새로 만든다. 	GROUP BY 이후의 수행절인 SELECT나 ORDER BY절에서 개별 데이터를 사용하는 경우 에러	가 발생한다.

		ASC : 오름차순으로 정렬( 숫자: 작->큰, 알파벳 : 앞->뒤) NULL값을 가장 작은 값으			로 간주하여 가장 앞으로 온다.
		DESC : 내림차순으로 정렬

	7) LIMIT
	가져올 행의 수를 지정하여 순서대로 행을 가져온다. OFFSET을 통해 첫행을 0부터 지정해 주		고, 조회할 행의 수를 입력한다.

	ROWNUM과 TOP N QUERY -> SQL SERVER와 ORACLE에서 사용.
		
	SELECT ENAME, SAL, FROM EMP
	WHERE ROWNUM < 4
	ORDER BY SAL DESC; -> 테이블상에서 위의 4건을 먼저 추출 한 뒤 정렬이 일어남.

	SELECT ENAME, SAL
	FROM ( SELECT ENAME, SAL FROM EMP ORDER BY SAL DESC)
	WHERE ROWNUM < 4 (=LIMIT(0,4)) -> 정렬을 먼저 하고 위의 4건의 데이터 추출

	SELECT TOP(4) ENAME, SAL FROM EMP
	WHERE ROWNUM < 4 
	ORDER BY SAL DESC; -> ORDER BY 절이 없다면 ROWNUM과 TOP의 기능은 같다. 하지만 정		렬이 일어나게 되면 SELECT 문장의 실행 순서에 따라 전혀 다른 방식으로 출력된다.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

계층형 질의 - 테이블에 계층형 데이터가 존재하는 경우 데이터를 조회하기 위해 계층형 질의를 사용

	순환관계 데이터 모델 -> 사원중에 관리자 사원이 존재해 같은 사원을 관리

	WITH 	(앵커멤버
		UNION ALL
		재귀멤버)
	SELECT
	FROM 

	-> WITH 절의 CTE 쿼리를 보면 UNION ALL연산자를 이용해 두개를 결합.
	위의 앵커 멤버를 싱행하여 첫번째 호출 또는 기본결과 집합(T0)를 만든다.
	Ti를 입력으로 사용하고 Ti+1은 출력으로 사용하여 재귀 멤버를 실행한다.
	빈 집합이 반환될 때까지 이 단계를 반복한 후 UNION ALL이 결과 집합이다.


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
STANDARD SQL

	STANDARA JOIN - CROSS JOIN, OUTER JOIN 등의 새로운 FROM 절 JOIN 기능

	SCALAR SUBQUERY, TOP-N QUERY 등의 새로운 SUBQUERY 기능

	ROLLUP, CUBE, GROUPING SET 등의 새로운 리포팅 기능 (GROUP FUNCTION)

	WONDOW FUNCTION 같은 새로운 개념 분석 기능 (분석함수와 순위함수)

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

1) JOIN - 두개 이상의 테이블들을 연결 또는 결합 하여 데이터를 출력하는 것. 관계형 데이터베이스의 가장 큰 장점이며 핵심 기능이다. 

	일반적인 경우 행들은 PRIMARY KEY나 FOREIGN KEY 값의 연관에 의해 JOIN이 성립한다. 어	떤 경우에는 관계가 없어도 논리적인 값들의 연관 만으로도 성립 가능하다.
	
	FROM 절에서 여러 테이블이 나열되더라도 SQL에서 데이터를 처리할 때는 단 두개의 집합간		에만 조인이 일어난다. 예를 들어 A, B, C테이블이 나열된 경우 특정 2개의 테이블만 먼저 조	인 처리되고, 2개의 테이블이 조인되어 처리된 새로운 데이터 집합과 남은 한개의 테이블이 	다음 차례에 조인되는 식이다.

	관계형 데이터베이스의 경우 요구사항 분석, 개념적 데이터 모델링, 논리적 데이터 모델링, 물		리적 데이터 모델링의 단계를 거치는데, 이 단계에서 엔터티(실체, 객체-정보가 될 수 있는 개		념) 확정 및 정규화 과정, 그리고 M:M(다수대 다수) 관계를 분해하는 절차를 거치게 된다. 정	규화 과정의 경우, 데이터 정합성과 데이터 저장 공간의 절약을 위해 엔터티를 최대한 분리하	는 작업으로, 일반적으로 3차 정규형이나 보이스코드 정규형까지 진행하게 된다. 이런 정규화	를 거치면 하나의 주제에 관련있는 엔터티가 여러개로 나누어지게 되고, 이 엔터티들이 부로 	테이블이 되는데 이렇게 흩어진 데이터를 연결해서 원하는 데이터를 가져오는 작업이 바로 	JOIN이라고 할 수 있다.

EQUAL JOIN과 NON EQUAL JOIN
	EQUAL JOIN - 두개의 테이블 간에 칼럼 값이 서로 정확하게 일치하는 경우에 사용되는 방법	으로 PK<->FK 의 관계를 기반으로 한다. 하지만 반드시 이 관계로만 EQUAL JOIN이 성립하	는 것은 아니다.
	이 기능은 계층형이나 망형 데이터베이스와 비교해서 관계형 데이터베이스의 큰 장점이다.

		SELECT 테이블1.칼럼명, 테이블2.컬럼명
		FROM 테이블1
		JOIN 테이블2
		ON 테이블1.칼럼명1 = 테이블2.칼럼명2; -> ON을 이용해 조건을 넣는다.
	
		-> '테이블명.칼럼명'과 같이 테이블명과 칼럼명을 같이 명시
		특정 칼럼에 접근하기 위해 그 칼럼이 어느 테이블에 존재하는 칼럼인지를 명시. 			JOIN에 사용되는 두개의 테이블에 같은 칼럼명이 존재하는 경우 파싱 단계에서 에		러가 발생한다. 가독성과 유지보수성을 높이는 효과가 있다.
		하나의 SQL문장 내에서 유일하게 사용하는 칼럼명이면 테이블명을 앞에 붙이지 않			아도 되지	만 오류를 방지하고 일관성을 위해 테이블명을 앞에 붙여 사용하는 것이 			좋다.
		ALIAS를 지정 하였으나 테이블 명을 사용할 경우 오류가 발생한다.

	NON EQUAL JOIN - '='연산자가 아닌 다른 (BETWEEN, <=, >=, <, >) 연산자를 사용하여 	JOIN을 수행한다.
	두개의 테이블이 PK-FK 연관관계를 가지거나 논리적으로 같은 값이 존재하는 경우에는 '=' 	연산자를 이용하여 EQUAL JOIN을 사용하지만 두개의 테이블 간에 칼럼 값들이 서로 정확하	게 일치하지 않는 경우에는 NON EQUAL JOIN을 사용할 수 있다.
	
		SELECT E.NAME, E.JOB, E.SAL, S.GRADE
		FROM EMP E, SALGRADE S
		WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;
		
		-> E.SAL의 조건을 S.LOSAL과 S.HISAL의 사이값으로 두고있다.
		CASE를 사용한 코딩과의 차이는???

FROM 절의 JOIN 형태
	
	INNER JOIN - OUTER JOIN과 대비하여 내부 JOIN이라고 하며 JOIN 조건에서 동일한 행이 있		는 행만 반환한다.
	
	NATURAL JOIN - 두 테이블 간의 동일한 이름을 갖는 모든 칼럼들에 대해 EQUAL JOIN을 수	행한다. NATURAL JOIN이 명시되면, 추가로 USING 조건절, ON 조건절, WHERE 조건절에서 	JOIN 조건을 정의할 수 없다.

		USING 조건절 - NATURAL JOIN에서는 모든 일치되는 칼럼들에 대해서 JOIN이 이		루어 지지만, FROM 절의 USING 조건절을 이용하면 같은 이름을 가진 칼럼들 둥에		서 원하는 칼럼에 대해서만 선택적으로 EQUAL JOIN 할 수 있다.

	ON 조건절 - JOIN 서술부(ON 조건절)와 비 JOIN 서술부(WHERE 조건절)을 분리하여 가독성	이 좋으며 칼럼명이 다르더라도 JOIN을 사용할 수 있다는 장점이 있다.
	
	CROSS JOIN - 일반 집합 연산자의 PRODUCT 개념으로 테이블간 JOIN 조건없이 발생 할 수 	있는 모든 데이터의 조합을 반환한다.

	OUTER JOIN - INNER JOIN과 대비하여 OUTER JOIN 이라 불리며, JOIN 조건에서 동일한 값이 	없는 행도 반환할 대 사용 할 수 있다.
		LEFT OUTER JOIN - 왼쪽 테이블을 기준으로 오른쪽 테이블의 칼럼값이 일치하는 		정보를 가져온다.
		RIGHT OUTER JOIN - 조회 집합 기준이 오른쪽 테이블
		FULL OUTER JOIN - 조회 집합 기준이 양쪽 테이블 모두

	SELF JOIN - 동일한 테이블 사이의 조인으로 FROM 절에서 동일한 테이블이 두번 이상 나타		나므로 조인을 수행하면 테이블과 칼럼 이름이 모두 동일하기 때문에 식별을 위해 		반드시 테이블 별칭(ALIAS)를 사용해야 한다. 칼럼에도 모두 별칭을 사용해서 어느 		테이블의 칼럼인지 식별해 줘야 한다.

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

2) SUBQUERY - 하나의 SQL 문 안에 포함되어 있는 또 다른 SQL 문을 말한다. 하나의 SQL문 만으로는 구하기 어려운 복잡한 SQL문에 사용. 알려지지 않은 기준을 이용한 검색을 위해 사용한다. 메인 쿼리 않에 서브쿼리가 포함된 종속 관계이다.
	서브쿼리는 괄호로 감싸서 사용한다.
	단일행 또는 복수행 비교 연산자와 함께 사용 가능하다.(단일행 비교 연산자는 서브쿼리의 결		과가 반드시 1건 이하여야 하고, 복수행 비교 연산자는 서브쿼리의 결과 건수가 상관 없다.
	서브 쿼리에서는 ORDER BY절을 사용하지 못한다. SELECT 절에서 오직 한개만 올 수 있기 때		문에 메인 쿼리의 마지막 문장에 위치해야 한다.

	사용 가능한 위치 	- SELECT 절, FROM 절, WHERE 절, HAVING 절, ORDER BY 절
			INSERT VALUES 절, UPDATE SET 절
	
	사용 위치에 따른 분류
		- SELECT 절에서 서브쿼리 사용 : 한 행, 한 컬럼 만을 반환. (함수를 사용하거나, 다			른 테이블 내의 데이터를 가져올 때 사용)

		- FROM 절에서 서브쿼리 사용 : FROM 절에서 사용되는 서크쿼리를 인라인 뷰(실			제 데이터는 가지고 있지 않지만 테이블의 역할은 수행한다.) 라고 한다. 가상의 테			이블을 만든 뒤, 그 테이블 상의 데이터를 이용해 데이터를 가져온다.
	
		- HAVING 절에서 서브쿼리 사용 : 그룹함수와 함께 사용 될 때 그룹핑 된 결과에 대			해 부가적인 조건을 주기 위해서 사용한다.

	연관 서브쿼리와 비 연관 서브쿼리
		연관 서브쿼리 : 서브쿼리 내에 메인쿼리의 칼럼이 사용된 서브 쿼리
		비 연관 서브 쿼리 : 서브쿼리 내에 메인쿼리의 컬럼이 쓰이지 않은 서브 쿼리

	반환 형태에 따른 분류
		- 단일 행 반환 서브쿼리 : 단일행 비교 연산자와 서브쿼리의 결과가 1건 				이하. 주로 비교 연산자와 함께 사용

		- 다중 행 반환 서브쿼리 : 다중행 연산자와 서브쿼리의 결과가 2건 이상
			IN, ANY, SOME, ALL, EXISTS

		- 다중 컬럼 반환 서브쿼리 : 2개 이상의 컬럼과 비교대상인 서브쿼리를 				비교
		WHERE (컬럼명1, 컬럼명2) IN (SELECT 컬럼명1, 컬럼명2 FROM )

		- 스칼라 서브 쿼리 : SELECT 절에 기술된 서브 쿼리.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

함수 (FUNCTION) - 특정 기능을 실행하는 객체

내장함수 
	단일행 함수 - 입력값이 단일행으로 입력

	SELECT, WHERE, ORDER BY 절에서 사용 가능. 각 행들에 대해서 개별적으로 작용하여 데이터 	값들을 조작하고, 각각 행에 대한 조작 결과를 리턴한다. 여러 인자를 입력해도 하나의 결과만 	리턴한다.

		문자형 함수 : 문자를 입력하면 문자나 숫자값을 반환한다.
		LOWER, UPPER, SUBSTR, LENGTH, [L/R]TRIM, ASCII
		
		숫자형 함수 : 숫자를 입력하면 숫자값을 반환한다.
		ABS, MOD, ROUND, TRUNC, SIGN, CHAR

		날짜형 함수 : DATE 타입의 값을 연산한다.
		GETDATE(), EXTRACT

		변환형 함수 : 문자, 숫자, 날짜형 값의 데이터 타입을 변환한다.
		TO_NUMBER, TO_CHAR, CONVERT

		CASE 표현 : IF THEN ELSE 논리와 유사한 방식으로 표현식을 작성
		CASE 	WHEN () THEN () 
			WHEN () THEN ()
			ELSE ()
		END
		-> 소스상의 순서대로 값을 정한다. ELSE가 없으면 NULL이 DEFAULT값.
		DECODE 구문으로도 축약 가능하다.
		SELECT DECODE(N,1,"ONE',2,'TWO','I CANNOT COUNT THAT HIGH" FROM 테이블

		NULL 관련 함수 - NULL을 처리하기 위한 함수
		NVL/ISNULL, NULLIF, COALESCE
		-> NULL 값이 아닌 값을 얻고자 할때는 ISNULL 함수를 이용해야 한다. 
			ISNULL(표현식1,표현식2) 표현식1의 결과값이 NULL이면 표현식2의 값이 			출력. -> CASE IS NULL THEN 과 같은 표현
			NULLIF(표현식1, 표현식2) 표현식1이 표현식2와 같으면 NULL, 같지않으			면 표현식1을 리턴
			COALESCE(표현식1, 표현식2) 임의의 개수의 표현식에서 NULL이 아닌 최				초의 표현식을 나타낸다. 모두 NULL이면 NULL을 리턴


	다중행 함수 - 여러 행들의 그룹이 모여서 그룹당 단 하나의 결과를 돌려준다.

		집계함수 -> GROUP BY 절은 행들을 소그룹화 한다.
			SELECT, HAVING, ORDER BY 절에서 사용 가능하다.
			집계함수의 통계 정보는 NULL 값을 가진 행을 제외하고 수행한다.

			COUNT(*) , COUNT(표현식), CUM, AVG, MAX, MIN, STDDEV, VARIAN

			CASE를 이용한 데이터의 집계 CASE ~ GROUP BY ~
			-> DBMS 자원 활용이나 처리 속도에서 효율적임. (데이터 건수가 많아질				수록)

			다중행 함수에서는 NULL 값을 제외하고 계산하므로 ISNULL들의 함수를 				사용할 필요가 없다.

			WHERE 절에서는 집계함수를 사용 할 수 없고, HAVING절에서는 사용 가				능
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
윈도우 함수 - 행과 행간의 관계를 쉽게 정의하기 위해 만든 함수
	중첩해서 사용하지는 못하지만, 서브 쿼리에서는 사용 가능하다.	

	분석 함수 -> 선형 분석을 포함한 통계 분석 함수
	
	순위 함수 -> RANK : 동일한 값에 대해서 동일한 순위 부여. 1,1,3
		DENSE_RANK : 동일한 값에 대해 동일한 순위를 부여. 1,1,2
		ROW_NUMBER : 동일한 값에 대해서도 다른 값을 부여. (행의 번호)
	
	집계관련 함수 -> SUM, MAX, MIN, AVG, COUNT

	그룹 내 비율 함수 -> PERCENT_RANK : 파티션별로 가장 먼저 나오는 값을 0, 가장 늦게 나오		는 값을 1로 하여 행의 순서별로 백분율을 구한다.
	
	SELECT
	윈도우 함수(표현) OVER ([PARTITON BY 컬럼] ORDER BY 컬럼 ROWS|RANGE BETWEEN () 		PRECEDING AND () FOLLOWING  )
	FROM

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GROUP 함수

	ROLLUP 함수 - LIST SUBTOTAL을 생성. 하나의 컬럼에 대해 GROUP BY ROLLUP을 시행하면 		한개의 SUBTOTAL 생성, 두개의 컬럼에 대해 시행하면 첫번째 컬럼을 기준으로 두번째 컬럼		들에 대해 SUBTOTAL을 만들고 첫번째 컬럼에 대한 GRAND TOTAL을 생성 -> 인수의 순서도 	중요하다.
	
	GROUPING 함수 - GROUPING을 사용하면 ROLLUP에 의해 생성된 SUBTOTAL이나 			GRANDTOTAL에 대해서는 1의 값을 리턴하고, 나머지에 대해서 0의 값을 리턴한다.

	CUBE 함수 - CUBE 함수에서는 결합 가능한 모든 값에 대해서 다차원 집계를 생성한다.
	첫번째 컬럼에 대한 두번째 컬름의 SUBTOTAL도 생성하고 두번째 컬럼에 대한 첫번째 컬럼		의 SUBTOTAL도 생성한다.

	GROUPING SET 함수 - GROUP 함수를 반복하지 않아도 원하는 결과를 얻게 해주는 함수.
	
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
데이터 분석 기획 -> 분석을 수행하기에 앞서 수행할 과제의 정의 및 의도했던 결과를 도출 할 수 있도록 적절하게 관리할 수 있는 방안을 사전에 계획

과제 중심적 -> 당면한 과제를 빠르게 해결
장기적인 마스터 플랜 -> 분석 과제 정의를 위해

분석 과제의 발굴 
	상향식 - 문제의 정의 자체가 어려운 경우. 데이터를 기반으로 해결방안 탐색. 지속적 개선 
		기업에서 보유하고 있는 다양한 원천 데이터로 부터 분석을 통해 통찰력과 지식을 			얻는다. 데이터의 분석 목적이 명확하지 않으며 데이터 자체의 결합, 연관성, 유사성 		들을 중심으로 상태 표현. 인과관계로 부터 상관관계 분석으로 이동. 빅테이터 분석			에서의 주요 변화. -> 왜그런지 알아 내는 것이 중요
	하향식 - 해결법을 찾기 위한 과정을 체계적으로 수행.

	-> 상향식과 하향식의 방식을 반복적으로 수행함에 따라 상호보완적으로 하는 것이 분석의 		가치를 높일 수 있다.

의미있는 분석이란? 분석 기술, IT 및 프로그래밍, 분석주제에 대한 도메인 전문성, 의사소통, 분석 대상 및 방식에 따른 다양한 주제를 과제 단위 혹은 마스터 플랜 단위로 도출 할 수 있어야 한다.

1) 비즈니스 이해 및 범위의 설정 -> 비즈니스에 대한 이해. 내부 업무 매뉴얼과 관련 자료, 외부 자료 조사를 통해 향후 방향을 설정. 프로젝트의 범위를 명확하게 설정.

2) 프로젝트 정의 및 계획 수립 -> 모델 운영 이미지를 설계하고, 모델 평가 기준을 설정. 프로젝트의 정의를 명확하게. 모든 프로젝트 수행계획을 작성( 데이터 확보의 계획, 빅데이터 분석 방법, 일정계획, 예산 계획, 품질 계획, 인력 구성 계획, 의사소통 계획) 프로젝트의 목적 및 배경, 기대효과, 수행 방법

3) 프로젝트 위험계획 수립 -> 발생 가능한 모든 위험을 발굴하여 사전에 대응방안을 수립.

데이터의 준비 -> 필요 데이터를 정의하고, 획득 방안을 수립.
		데이터 스토어 설계 -> 구조화된 형식. 관계형 데이터베이스 사용.
		효율적인 저장과 활용을 위해 논리적 물리적 설계를 구분하여 설계
		데이터 수집 및 정합성 점검. (데이터의 전처리, 노이즈 제거)

데이터 분석 -> 분석용 데이터의 준비
		텍스트 분석 -> 텍스트데이터 확인 및 추출 후 데이터 분석
		탐색적 분석 -> 다양한 데이터의 시각화를 활용하여 가독성을 높이고, 데이터 형상 			및 분포 등의 데이터 특성을 파악하는 데스크.

		모델링 -> 분석용 데이터를 이용한 가설 설정을 통해 통계 모델을 만들거나 데이터			의 분류, 예측, 군집(데이터 마이닝) 들의 기능을 수행하는 모델을 만든다.
		과적합과 일반화를 위해 훈련용과 테스트용으로 나눈다.
		데이터 분할 -> 데이터 모델링 -> 모델 적용 및 운영방안 -> 모델평가 및 검증

시스템 구현 -> 알고리즘 설명서에 근거하여 실제 시스템을 구축하고 테스트를 통해 안전성을 확보, 지		속적으로 사용 가능하도록 메뉴얼 생성

평가 및 전개 -> 모델링한 것을 계속 사용할 수 있도록 발전계획을 세우로 프로젝트 성과를 평가한 뒤 		보고서를 작성하여 산출물 및 프로세스를 지식 자산화

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

데이터 마이닝 기법 - 대규모로 저장된 데이터 안에서 체계적이고 자동적으로 통계적 규칙이나 패턴을 찾아 내는 것

	지도 학습 - 예측 : 주어진 데이터를 근거로 모델을 만들고 그 모델을 이용하여 새로운 케이스		들을 예측, 분류(명확히 나누어진) : 일련의 범주들이 사전에 분류되어 있을때 특정한 케이스	가 어디에 속하는 가를 결정

	비지도 학습 - 군집(애매한. 키와 같은) : 데이터의 여러 속성들을 비교하여 유사한 특성을 갖		는 항목들을 함께 모으는 것, 연관규칙 : 한 패턴의 출현이 다른 패턴의 출현을 암시하는 속성		이나 항목간의 관계를 파악

	K 평균 군집화 - 주로 군집화 작업에 사용. 각각의 속성으로 구성되는 레코드를 벡터로 표시	하여 N차원 공간에 나타낸 후 유사한 특성을 갖는 레코드들을 서로 근접하여 위치한다는 가	정에 근거. 임의로 K개의 중심점을 기준으로 군집을 만든다. 중심으로 부터의 분산을 계산을 	하여 최소화 하도록 중심점의 위치를 바꾼다.
		장점 : 사용이 간편하고 쉽다. 군집 이외에도 분류, 예측을 위한 선행작업 특히 오류			값이나 결손값 처리작업 등 다양한 분석에서 사용 가능
		단점 : 속성들의 형태가 다르거나 같은 형태의 속성이라도 값의 범위가 다양할 경우 		거리 측정 기준을 설정하는데 어려움이 있다. 		


	의사결정 나무 - 데이터 마이닝 분류 작업에서 주로 사용되는 기법. 과거에 수집된 데이터의 		레코드를 분석하여 이들 사이에 존재하는 패턴, 부류별 특성을 속성의 조합으로 나타낸 분류		모형을 나무의 형태로 만드는 것. 이렇게 만든 분류모형을 이용해 새로운 레코드를 분류하고 		예측하는데 사용.
	LIKE 스무고개 가장 영향력이 큰 속성을 뿌리쪽으로 분류.
	과잉 맞춤 -> 너무 모든 정보를 담으려고 하면. 규칙 자체가 엉뚱한 의미를 갖는다
	가지치기를 통해 의미없는 가지를 친다.
		장점 : 분류나 예측의 근거를 알려줘 이해가 쉽다. 분류에 영향을 미치지 않는 속성			을 자동으로 제외하기 때문에 데이터 선정이 용이. 변환 단계에서 소요되는 기간과 			노력을 단축. 속성마다의 영향을 쉽게 파악 가능. 모형 구축에 소요되는 시간이 짧		다.
		단점 : 나이와 소득같이 연속형의 데이터 처리 능력이 떨어진다. 연속형 변수가 포		함된 경우 이산형이나 범주값으로 변환을 해야한다. 이런 과정에서 그룹화에 치우		침을 배제할 수 없다. 모형 구축에 있어서 표본의 크기에 지나치게 민감하다. 서로 		상이한 값을 갖는 데이터가 많이 필요하다.


	신경망 - 의사결정 세포와 마찬가지로 과거에 수집된 데이터로 부터 반복적인 학습과정을 거		쳐 데이터에 내재되어 있는 패턴을 찾아내는 방식. 분류, 군집, 연관규칙 발견과 같은 작업에 		주로 가용된다. 각각의 값의 범위를 0-1 사이의 값으로 변환하여 계산을 한다.
		장점 : 입력 출력 마디에 연속형 변수를 사용 할 수 있다. 적용할 수 있는 문제의 영			역이 의사결정 나무 보다 넓다. 결과를 비선형 조합을 통해 제공하기 때문에 예측력			이 우수하다.
		단점 : 분류나 예측 결과만을 제공할 뿐 왜 그런 결과가 나왔는지에 대한 설명을 하			지 못한다. 근거가 요구되는 영역에서는 적합하지 않다. 모든 입력변수와 출력변수			를 변환해야 하기 때문에 추가적인 시간과 노력이 요구된다. (최근에는 자동화) 모		형 구축에 시간이 많이 소요된다. 

스타트업 데이터 분석

	코호트 분석(동질 집단 분석) - 특정 기간동안 공통된 특성이나 경험을 갖는 사용자 집단. 날			짜에 기반한 사용자 세그먼트 (주로 시간의 흐름에 따른 코흐트 간의 상이한 행동 			패턴 들의 분석을 통해 인사이트를 도출)
		장점 : 현 상황에 대한 정확한 정보를 얻을 수 있다.(표면적인 상황과 다른)
		앱의 경우 -> 설치 이후의 데이터가 꼭 필요. 클릭과 설치수 라는 적은 성과지표

		CTR (CLICK THROUGH RATE)

	퍼널 분석(유저행동을 단계별로 분석) - 각 단계별로 좁아지는 형태의 그래프. 단계별로의 이			탈률을 분석하여 제일 높은 부분부터 개선. 떠나가는 유저들에 대해서 그들이 나가			는 시점과 이유를 밝히는 것이 중요.

		최종 목표를 설정 -> 깔떼기 단계 설정 -> 단계별 이탈률 측정

		취약점을 분석하는 것이 중요. 어디가 문제인지, 왜 문제인지를 찾아야 함.

	데이터 알고리즘

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	A.I > 머신러닝 > 딥러닝

	A.I 
		지능형 기계를 만드는 과학 및 공학. 컴퓨터에서 지능적인 행동을 시뮬레이션 하는 		컴퓨터 과학 분야. 지능적인 인간의 행동을 모방하는 기계의 능력.

	DEEP LEARNING 
		심층 인공 신경망. 이미지 인식, 음성인식, 추천시스템, 자연어 처리와 같이 중요한 		문제들에 대한 정확도에 대한 알고리즘.


	MACHINE LEARNING
		인공지능의 부분집합. 더 많은 데이터를 접했을때 스스로를 수정하는 능력. 동적으		로 작동하여 특정한 변화를 하기 위해 인간의 개입이 필요하지 않다.
		-> 추측 값과 실제 정답 값을 대조하여 오류값을 수정. 해당 오류값을 사용하요 알		고리즘을 수정 '신경망의 학습' (최적화 알고리즘)

		최적화 알고리즘 (머신러닝) -> 경사하강법(GRADIENT). 뉴턴 방법.
		이동 방향과 이동크기를 어떻게 정할 것인가.
			경사 하강법 : 항상 올바른 방향으로 가지만 수렴속도가 문제가 된다. 너			무 느릴수도 있고 너무 크면 발산 해버린다.
			뉴턴 : 이차미분을 사용 -> 변곡점에서 매우 불안정하다. 극소 극대를 구			분하지 않는다.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

데이터 모델링의 이해 정리

데이터 모델링의 특징
	1) 추상화 - 현실 세계의 다양한 현상을 일정한 형식에 맞추어 표현.
	2) 단순화 - 약속된 규약에 의해 제한된 표기법이나 언어로 표현하여 쉽게 이해.
	3) 명확화 - 누구나 이해하기 쉽도록 애매모호함을 제거하고 정확하게 현상을 기술.

데이터의 품질을 떨어트리는 요인
	1) 중복 - 동일 자료의 중복
	2) 비유연성 - 잘못된 데이터 모델은 사소한 업무변화에 대응하지 못하고 유지보수에 어려움	이 따른다.
	3) 비일관성 - 데이터의 모순, 데이터 간의 상호 연관관계에 대한 정확한 정의로 이러한 위험	을 예방

데이터 모델링의 3단계
	개념적 데이터 모델링(추상적) - 추상화 수준의 높고 업무중심적이고 포괄적 수준의 모델링.
	논리적 데이터 모델링 - 시스템으로 구축하고자 하는 업무에 대해 KEY, 속성, 관계 들을 정확	하게 표현.
	물리적 데이터 모델링(구체적) - 실제 데이터베이스에 이식할 수 있도록 성능, 저장 등 물리적	인 성격을 고려하여 설계

데이터베이스의 3단계 구조
	외부 스키마 : 여러개의 사용자 관점으로 구성. 개개 사용자 단계로서 사용자가 보는 개인적 	DB 스키마. (사용자 VIEW 단계)
	개념 스키마 : 하나의 개념적 스키마로 구성. 모든 사용자 관점을 통합한 조직 전체의 DB를 	구성하는 것. (전체적인 VIEW 단계)
	내부스키마 : DB가 물리적으로 저장된 형식. 물리적 장치에서 데이터가 실제적으로 저장되는 	방법을 표현하는 스키마. (저장 스키마)

ERD (ENTITY RELATIONSHIP DIAGRAM)의 이해
	- 작업 순서 
		엔터티를 그린 후 적절히 배치한다.
		엔터티 간의 관계를 설정한다.
		관계명을 기술한다.
		관계의 참여도를 기술한다.
		관계의 필수 여부를 기술한다.

		-> 좌에서 우로, 위에서 아래로 배치. 중심이 되는 엔터티를 중앙에 배치.

		-> 관계명은 현재형을 사용. 지나치게 포괄적인 용어는 사용하지 않는다.
		동사를 사용, 실무에서는 생략해도 무방

좋은 데이터 모델의 요소
	완전성(COMPLETENESS), 중복배제(NON-REDUNDANCY), 업무규칙(BUSINESS RULES), 
	데이터 재사용(DATA REUSEABILITY), 의사소통(COMMUNICATION), 통합성(INTERGRATION)

엔터티(ENTITY)

	업무에서 반드시 필요로 하는 정보
	유일한 식별자에 의해 식별이 가능
	2개 이상의 INSTANCE의 집합
	업무 프로세스가 반드시 ENTITY를 사용
	반드시 ATTRIBUTE를 포함.
	다른 ENTITY와 최소 한개 이상의 관계가 존재

	유형엔터티 - 물리적인 형태가 있고 안정적이며 지속적으로 활용되는 ENTITY.
	개념엔터티 - 물리적인 형태는 존재하지 않고 관리해야할 개념적 정보로 구분되는 ENTITY
	사건엔터티 - 업무를 수행함에 따라 발생되는 ENTITY

	기본엔터티(KEY) - 그 업무에 원래 존재하는 정보로서, 다른 ENTITY와 관계에 의해 생성되지 		않고 독립적으로 생성 가능. 다른 ENTITY로부터 주식별자를 상속받지 않고 자신의 고유 식별		자를 가짐.
	중심엔터티(MAIN) - 기본 ENTITY로부터 발생되고, 업무에 있어서 중요한 역할을 한다.
	행위엔터티(ACTIVE) - 두개 이상의 부모 ENTITY로부터 발생되고 자주 내용이 바뀌거나 데이		터량이 증가한다.
	
	가능하면 현업업무에서 사용하는 용어를 사용한다.
	약어를 사용하지 않는다.
	단수명사를 사용한다.
	모든 ENTITY에서 유일하게 이름이 부여되어야 한다.
	생성의미대로 이름을 부여한다.

속성(ATTRIBUTE)

	업무상 필요로 하는 인스턴스로 관리하고자 하는 의미상 더이상 분리되지 않는 최고의 데이	터 단위

	정규화 이론에 근간하여 정해진 주식별자에 함수적 종속성을 가져야 한다.
	하나의 속성은 하나의 값만 가진다
	만약 여러값이 존재하는 경우, 별도의 ENTITY를 이용하여 분리한다.

	기본속성 - 업무로부터 추출한 모든 속성.
	설계속성 - 코드성 데이터, ENTITY 식별용 일렬번호.
	파생속성 - 다른 속성에 영향을 받아 발생하는 속성.

	해당 업무에서 사용하는 이름을 부여.
	서술식 속성명은 사용하지 않는다.
	약어 사용은 가급적 제한한다.
	전체 데이터모델이서 유일성을 확보하는 것이 좋다.

도메인(DOMAIN)

	속성이 가질 수 있는 값의 범위

관계(RELATIONSHIP)

	인스턴스 사이의 논리적인 연관성으로 존재 또는 행위로서 서로에게 연관성이 부여된 상태

	존재에 의한 관계
	행위에 의한 관계

	관계의 3요소
	-> 관계명, 관계차수, 관계선택사양

식별자

	ENTITY 내에서 INSTANCE 들을 구분할 수 있는 구분자

	유일성 - 주식별자에 의해 ENTITY 내의 모든 INSTANCE 들을 유일하게 구분함
	최소성 - 주식별자가 구성하는 속성의 수는 유일성을 만족하는 최고의 수가 되어야 함
	불변성 - 주식별자가 한번 특정 ENTITY를 지정하면 그 값은 변하지 말아야 함
	존재성 - 주식별자가 지정되면 반드시 데이터 값이 존재

	주식별자 - ENTITY 내에서 각 어커런스를 구분할 수 있는 구분자. 타 엔터티와 참조관꼐를 연	결할 수 있는 식별자
	보조식별자 - ENTITY 내에서 각 어커런스를 구분할 수 있는 구분자이나 대표성을 가지지 못	해 참조연결을 못함

	내부식별자 - 엔터티 내부에서 스스로 만들어지는 식별자
	외부식별자 - 타 엔터티와의 관계를 통해 타 엔터티로부터 받아오는 식별자
		
	단일식별자 - 하나의 속성으로 구성된 식별자
	복합식별자 - 둘 이상의 속성으로 구성된 식별자

	본직식별자 - 업무에 의해 만들어지는 식별자
	인조식별자 - 업무적으로 만들어지지는 않지만 원조 식별자가 복잡한 구성을 가지고 있기 때	문에 인위적으로 만드는 식별자

	주식별자 도출 기준
		해당 업무에서 자주 이용되는 속성을 지정
		명칭, 내역들과 같이 이름으로 기술되는 것을 피함
		속성의 수가 많아지지 않도록 함
		
	식별자관계 - 부모로부터 받은 외부식별자를 자신의 주식별자로 이용
	비식별자관계 - 부모로부터 받은 외부 식별자를 부모와 연결되는 속성으로만 이용

















