옵티마이저
	옵티마이저는 사용자가 질의한 SQL 문에 대해 최적의 실행 방법을 결정하는 역할을 수행한다.
	옵티마이저가 선택한 실행 방법의 적절성 여부는 질의 수행 속도에 가장 큰 영향을 미치게 된다.
	옵티마이저가 최적의 방법을 결정하는 방식에는 규칙기반 (RBO, RULED BASED OPTIMIZER)와 비용기반(CBO, COST BASED OPTIMIZER) 로 구분한다.
	현재는 비용기반 위주로 신규 기능에 지원되고, 규칙위반에서는 신규 기능에 대해서 지원하지 않는다.

	- 규칙기반 옵티마이저
	규칙기반 옵티마이저가 실행계획을 생성할 때 참조하는 정보에는 SQL문을 실행하기 위해서 이용 가능한 인덱스 유무와(유일, 비유일, 단일, 복합 인덱스) 종류, SQL문 에서 사용하는 연산자 (=,<,<>, LIKE, BETWEEN 등)의 종류 그리고 SQL문에서 참조하는 객체 (힙, 테이블, 클러스터 테이블 등)의 종류 등이 있다.
	규칙기반은 인덱스를 이용한 액세스 방식이 전체 테이블 액세스 방식보다 우선 순위가 높다.
	그러므로 규칙기반 에서는 SQL문에서 이용 가능항 인덱스가 존재한다면 전체 테이블 액세스 방식보다 항상 인덱스를 사용하는 실행계획을 생성하게 된다.
	규칙기반 옵티마이저가 조인 순서를 결정할 때는 조인 칼럼 인덱스의 존재 유무라 중요한 판단기준이다.

	- 비용기반 옵티마이저
	규칙기반은 어떠한 정해진(연산자) 규칙에 따라 만들어졌을때 BETWEEN의 현실적인 데이터 건수 들을 측정을 예측하지 못한다.
	비용기반은 이러한 단점을 극복하기 위해서 출현하였다.
	비용기반은 SQL문을 처리하는데 필요한 비용이 가장 적은 실행계획을 선택하는 방식이다.
	비용이란 SQL문을 처리하기 위해 예상되는 소유시간 또는 자원 사용량을 의미한다.
	비용기반은 테이블, 인덱스, 칼럼 등의 다양한 객체 통계정보와 시스템 통계정보 등을 이용한다.
	비용기반은 통계정보가 없는 경우 불확실한 실행계획을 생성 할 수 있으므로 정확한 통계정보를 유지하는 것이 중요한 요소이다.

	비용기반 옵티마이저의 구성

	질의 변환기 -> 대안 계획 생성기 <- 비용 예측기 
			------------------------> 대안 계획
	질의 변환기는 사용자가 작성 SQL문을 처리하기에 보다 용이한 형태로 변환하는 모듈
	대안 생성기는 동일한 결과를 생성하는 다양한 대안 게획을 생성하는 모듈
		대안 계획은 연산 적용순서 변경, 연산방법변경, 조인순서변경 등을 통해 생성
		동일한 결과를 생설하는 가능한 모든 대안 계획을 생성해야 보다 나은 최적화를 수행
		대안 계획 생성이 너무 많아지면 최적화 하는 수행시간이 그만큼 오래 걸릴 수 있다.
	비용예측기는 대안 계획생성기에 의해 생성된 대안 계획의 비용을 에측하는 모듈
		대안계획의 정확한 비용을 예측하기 위해서 연산의 중간 집합의 크기 및 결과집합의 크리, 분포도 등의 예측이 정확해야 한다.
		대안계획을 구성하는 각 연산에 대해 비용 계산식이 정확해야 한다.
	비용기반은 통계정보, DBMS버전, DBMS설정에 의해 동일한 SQL 실행계획이 틀어질 수 있다.
	비용기반은 다양한 한계들로 인해 실행계획의 예측 및 제어가 어렵다라는 단점이 존재한다.
	

실행 계획
	실행계획이라는 SQL에서 요구한 사항을 처리하기 위한 절차와 방법을 의미한다.
	실행계획생성한다는 것은 SQL을 어떤 순서로 어떻게 실행할 지를 결정하는 작업이다.
	실행계획은 데이터베이스 벤더마다 서로 다르다.
	실행계획에서 표시되는 내용 및 형태도 약간씩 차이는 있지만 실행계획이 SQL 처리를 위한 절차와 방법을 의마한다는 기본적인 사항은 모두 동일하다.
	
	조인작업을 수행 할 때 참조하는 테이블 순서
	FROM 절 A,B 두개의 테이블이 존재할 때 조인 작업을 위해 먼저 A테이블을 읽고 B테이블을 읽는 작업을 수행한다면 조인 순서는 A->B이다.
	조인 순서는 EMP->DEPT이다.
	조인기법은 NL JOIN, HASH JOIN, SORT JOIN, MERGE JOIN 등이 있다.
	액세스 기법은 인덱스를 이용하여 테이블을 액세스 하는 인덱스 스캔과 테이블 전체를 모두 읽으면서 조건을 만족하는 행을 찾는 전체테이블 스캔이 있다.
	최적화 정보는 옵티마이저가 실행계획의 각 단계마다 예상되는 비용을 표시 한것이다.
	최적화 정보에는 COST(상대적비용), CARD(주어진 조건을 만족한 결과 집합 혹은 조인 조건을 만족한 결과 집합건수), BYTES(결과집합이 차지하는 메모리양) 가 있다.
	연산은 여러가지 조작을 통해서 원하는 결과를 얻어내는 일련의 작업이다.
	연산에는 조인기법, 액세스기법, 필터, 정렬, 집계, 뷰 등 다양한 종류가 존재한다.

SQL 처리 흐름도
	SQL 처리 흐름도란 SQL 내부적인 처리 절차를 시각적으로 표현한 도표이다.
	조인 순서는 TAB1 -> TAB2
	TAB1을 OUTER TABLE 또는 DRIVING TABLE이라고 하고, TAB2를 INNER TABLE 또는 LOOKUP TABLE 이라고 한다.
	테이블 액세스 방법은 TAB1은 전체 테이블 스캔을 의미하고, TAB2는 I01-TAB2라는 인덱스를 통해 인덱스 스캔을 했음을 표시한다.
	조인 방법은 NL JOIN 을 수행했음을 표시한다.
	TAB1에 대한 액세스는 스캔 방깃이고 조인시도 및 I01-TAB2 인덱스를 통한 TAB 액세스는 랜덤 방식이다.
	대량의 데이터를 랜덤방식으로 액세스 하면 많은 I/O가 발생하여 성능은 저하된다.


////////////////////////////////////////////////////////////////////////////////////////////////////////////////

인덱스

인덱스 특징과 종류
	인덱스는 원하는 데이터를 쉽게 찾을 수 있도록 돕는 색인과 유사한 개념이다.
	인덱스는 테이블을 기반으로 선택적으로 생성할 수 있는 구조이다.
	인덱스의 기본적인 목적은 검색 성능의 최적화이다.
	검색 조건을 만족하는 데이터를 인덱스를 통해 효과적으로 찾을 수 있도록 돕는다.
	DML 작업은 테이블과 인덱스를 합께 변경하므로 느려지는 단점이 존재한다.

	트리 기반 인덱스 (B트리 기반 인덱스 - ROOT BLOCK -> BRANCH BLOCK -> LEAF BLOCK)
	DBMS에서 가장 일반적인 인덱스이다.
	B 트리 인덱스는 브랜치 블록과 리프 블록으로 구성한다.
	브랜치 블록 중 가장 상위에 있는 블록을 루트 블록이라 한다.
	브랜치 블록은 분기를 목적으로 하는 블록이다.
	리프 블록은 트리 가장 아래 단계에 존재한다.
	리프 블록은 인덱스를 구성하는 칼럼의 데이터와 해당 데이터를 가지고 있는 행의 위치를 가리키는 레코드 식별자로 구성된다.
	인덱스 데이터는 인덱스를 구성하는 칼럼의 값으로 정렬된다.
	인덱스 데이터의 값이 동일하면 레코드 식별자 순서로 저장된다.
	리프 블록은 양방향 링크를 가지고 있다. (이것을 이용해 오름차순과 내림차순 검색을 쉽게 한다.)
	B 트리 인덱스는 '=', 'BETWEEN','>'등과 같은 연산자로 검색 구조에 적합한 구조이다.

	EX) 특정 숫자를 찾는 과정. 
		1. 브랜치 블록의 가장 왼쪽 값이 갖고자 하는 값보다 작거나 같으면 왼쪽 포인터로 이동.
		2. 찾고자 하는 값이 브랜치 블록의 값 사이에 존재하면 가운데 포인터로 이동.
		3. 오른족에 있는 값보다 크면 오른쪽 포인터로 이동.

	인덱스를 생성할 때 동일 칼럼으로 구성된 인덱스를 생성할 수 없다.
	인덱스 구성 칼럼은 동일하지만 칼럼의 순서가 다르면 서로 다른 인덱스로 생성할 수 있다.
	(JOB+SAL, SAL+JOB)
	인덱스 칼럼의 순서는 성능에 중요한 영향을 미치는 요소이다.
	
	
	클러스터형 인덱스
	SQL SERVER의 인덱스 종류는 저장 구조에 따라 클러스터형, 비클러스터형 인덱스로 나뉜다.
	


