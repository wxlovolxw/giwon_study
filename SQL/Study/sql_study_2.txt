 * SQL 기본

	1. DDL ( DATA DEFINITION LANGUAGE)
		데이터 유형
			* VARCHAR, CHAR은 작은 따옴표나 큰따옴표로 묶어서 비교처리 해야함.
			NUMERIC같은 숫자형 데이터는 인용부표를 사용 안함.

		CREATE TABLE
		ALTER TABLE
		RENAME TABLE
		DROP TABLE
		TRUNCATE TABLE

	2. TCL ( TRANSACTION CONTROL LAGUAGE)

/////////////////////////////////////////////////////////////////////////////////////////////////////////
	3. DML ( DATA MANIPULATION LANGUAGE)
		INSERT
		UPDATE
		DELETE
		SELECT -> 입력한 자료들을 조회하는 SQL

		* SELECT [*(ALL)/DISTINCT] 보고 싶은 컬럼명, 보고 싶은 컬럼명, ..
		FROM 해당 컬럼들이 있는 테이블명;
			- ALL - DEFAULT 옵션이므로 별도 표시 안해도 된다. 중복된 데이터도 모			두 출력한다.
			- DISTINCT - 중복된 데이터가 있는 경우 1건으로 처리해서 출력한다.
		ALIAS 부여하기. 조회된 결과에 일종의 별명을 부여해 칼럼의 레이블을 변경한다.
		컬럼 바로 뒤에 오며 칼럼명과 ALIAS 사이에 AS 키워드를 사용할 수도 있다.
		이중 인용부호는 ALIAS가 공백, 특수문자를 포함할 경우와 대소문자 구분이 필요한 			경우 사용한다.
		
		산술 연산자와 합성 연산자 
		산술연산자 ->  NUMBER와 DATE 자료형에 대해서 적용되며 일반적으로 수학에서의 		4칙연산과 동일하게 적용.
		우선순위를 위한 괄호 적용 가능. 일반적으로 산술 연산을 사용하거나 특정 함수를 			적용하게 되면 칼럼의 라벨이 길어지게 되므로 적절한 ALIAS를 새롭게 부여하는 것			이 좋다.
		우선순위 -> () * / + -

		합성연산자 -> 문자와 문자를 연결하는 합성 연산자. 
		오라클의 경우 두 문자 사이에 ||, SQL SERVER은 +FH DLFNDJWLSEK.
		공통적으로 CONCAT(STRING1, STRING2)로 합성 가능하다.
		문자 표현식의 결과에 의 해 새로운 칼럼을 생성한다.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
		WHERE -> 자신이 원하는 자료만을 검색하기 위해서 SQL 문장에서 WHERE 절을 이			용하여 자료들에 대해여 제한 할 수 있다.
		WHERE 조건절을 사용하지 않고 필요 없는 많은 자료들을 데이터베이스로 부터 요헝			하는 SQL 문장은 해당 DATABASE의 CPU와 메모리를 과다 사용하게 되어 성능을 저			하 시키게 된다. 뿐만 아니라 조건이 없는 SELECT 문은 테이블 전체를 읽게 되어 데			이터 양에 따라 성능을 저하 시키게 된다. 
		
		SELECT [ALL/DISTINCT] 칼럼명 [ALIAS명] FROM 테이블명 WHERE 조건식;
			조건식의 구성 : 칼럼명(보통 조건식의 좌측에 위치)
				비교 연산자
				문자, 숫자, 표현식(조건식의 우측에 위치)
				비교 컬럼명(JOIN 사용시)
		비교연산자 =, >, >=, <, <=, <>(!=)	
			문자 유형 비교 방법
			* 비교연산자의 양쪽이 모두 CHAR인 경우 
			-> 길이가 서로 다르다면 작은 쪽에 SPACE를 추가하여 길이를 같게 한다.
			서로 다른 문자가 나올 때 까지 비교한다.
			달라진 첫 번째 문자의 값에 다라 크리를 결정한다.
			BLANK의 수만 다르다면 서로 같은 값으로 결정한다.	
			* 비교연산자의 어느 한 쪽이 VARCHAR인 경우
			-> 서로 다른 문자가 나올 때까지 비교한다,
			길이가 다르다면 짧은 것이 끝날때까지 비교한 수 길이가 긴 것이 크다고 			판단한다.
			길이가 같고 다른 것이 없다면 같다고 판단한다.
			VARCHAR는 NOT NULL 까지의 길이를 말한다.
			* 상수값과 비교할 경우
			-> 상수 쪽을 변수 타입과 동일하게 바꾸고 위의 경우와 비교한다.
		
		SQL연산자
			BETWEEN A AND B
			-> A와 B를 포함하는 범위의 값
			IN
			-> 리스트에 있는 값 중에서 어느 하나라도 일치하면 된다.
			LIKE '문자열'
			-> 비교 문자열과 형태가 일치하면 된다.
			% : 0개 이상의 문자열, _ : 1개의 단일문자.

		IS NULL
			존재하지 않는 확정되지 않은 값을 표현할 때 사용하며 비교연산자와 비교 			자체가 불가능 하다.
			NULL과의 수치 연산은 NULL을 리턴.
			NULL과 비교하면 거짓{FALSE)을 리턴.
		
		논리연산자 -> 조건들을 논리적으로 연결시키기 위해 사용되는 연산자
			AND : 앞에 있는 조건과 뒤에 오는 조건이 참이 되면 결과도 참이 된다. 앞			의 조건과 뒤의 조건을 동시에 만족해야 하는 것이다.
			OR : 앞의 조건이 참이거나 뒤의 조건이 참이면 결과도 참이다. 앞뒤의 조			건 둥 하나만 참이면 된다.
			NOT : 뒤에 오는 조건에 반대되는 결과를 되돌려 준다.

		부정연산자 -> 비교연산자, SQL연산자에 대한 부정표현을 부정논리 연산자, 부정 			SQL연산자로 구분할 수 있다.
			부정논리연산자(비교연산자에 대한)
				!=, ^=, <> : 같지 않다.
				NOT 칼럼명 = : ~와 같지 않다.
				NOT 칼럼명 > : ~와 크지 않다.
			부정SQL연산자(SQL연산자에 대한)
				NOT BETWEEN A AND B : A와 B값 사이에 없다. (A,B포함 X)
				NOT IN(LIST) : LIST 값과 일치하지 않는다.
				IS NOT NULL : NULL 값을 갖지 않는다.
			
		ROWNUM, TOP -> SQL 처리 결과 집합의 각 행에 대해 임시로 부여되는 일렬번호. 
			테이블이나 집합에서 원하는 만큼의 행만 가져오고 싶을 때 WHERE 절에				서 행의 개수를 제한하는 목적으로 사용한다. (-> LIMIT?????)
			
			ROWNUM 
			한건만 가져올때. WHERE ROUNUM = 1, <=1, <2;
			N건을 가져올때. WHERE ROUNUM <=N, <N+1 
			
			TOP -> 집합으로 출력되는 행의 수를 제한.
			TOP (EXPRESSION->반환할 행의 수를 지정) [PERCENT] [WITH TIES]
				PERCENT : 쿼리 결과 집합에서 처음 EXPRESSION%DML 행만 반				환.
				WITH TIES : ORDER BY 절이 지정된 경우에만 사용할 수 있으며
				TOP N(PERCENT)의 마지막 행과 같은 값이 있는 경우 추가 행이 				출력되도록 지정.
			한건만 가져올때. SELECT TOP(1) PLAYER_NAME FROM PLAYER;
			N건 이상을 가져올 때. SELECT TOP(N) PLAYER_NAME FROM PLAYER;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	함수(FUNCTION)
	1. 내장 함수(BUILT-IN-FUNCTION)
		단일행 함수 - 입력값이 단일행이 입력.
			문자형 함수 - 문자를 입력하면 문자나 숫자값을 반환한다.
			: LOWER, UPPER, SUBSTR/SUBSTRING, LENGTH/LEN, LTRIM, RTRIM, TRIM, 			ASCII
				- LOWER(문자열) 문자열의 알파벳 문자를 소문자로 바꾼다.
				EX) LOWER('SQL EXPERT') -> 'sql expert'
				- UPPER(문자열) 문자열의 알파벳 문자를 대문자로 바꾼다.
				EX) LOWER('sql expert') -> 'SQL EXPERT'
				- ASCII(문자) 문자나 숫자를 ASCII 코드 번호로 바꾸어 준다.
				EX) ASCII('A') -> 65
				- CHR/CHAR(ASCII번호) ASCII 코드 번호를 숫자로 바꾸어 준다.
				EX) CHR(65) -> 'A'
				- CONCAT(문자열1, 문자열2) 문자열1과 문자열2를 연결한다.
				EX) CONCAT('RDBMS',' SQL') -> 'RDBSM SQL'
				- SUBSTR/SUBSTRING(문자열,M[,N]) 문자열 중 M위치에서 N개					의 문자 길이에 해당하는 문자를 돌려준다. N이 생략되면 마지막 				문자까지 반환한다.
				EX) SUBSTR('SQL EXPERT', 5, 3) -> 'EXP'
				- LENGTH/LEN(문자열) 문자열의 갯수를 숫자값으로 돌려준다.
				EX) LENGTH('SQL EXPERT') -> 10
				- LTRIM(문자열[,지정문자]) 문자열의 첫 문자부터 확인하며 지정 				문자가 나타나면 해당 문자를 제거한다. (지정 문자가 없으면 공					백값이 디폴트)
				EX) LTRIM('xxxYYZZxYZ','x') -> 'YYZZxYZ'
				- RTRIM(문자열[,지정문자]) 문자열의 마지막 문자부터 확인.
				EX) RTRIM('XXYYzzXYzz','z') -> 'XXYYzzXY'
				EX) RTRIM('XXYYZZXYZ     ') -> 'XXYYZZXYZ'
				- TRIM([LEADING|TRAILING|BOTH]지정문자FROM문자열) 문자열					에서 머리말, 꼬리말, 또는 양쪽에 있는 지정 문자를 제거한다.					BOTH가 디폴트 
				EX) TRIM('x' FROM 'xxYYZZxYZxx') -> 'YYZZxYZ'


			숫자형 함수 - 숫자를 입력하면 숫자값을 반환한다.
			: ABS, MOD, ROUND, TRUNC, SIGN, CHR/CHAR, CEIL/CEILING, FLOOR, 				XP, LOG, LN, POWER, SIN, COS, TAN
				- ABS(숫자) 숫자의 절대값을 돌려준다.
				- SIGN(숫자) 숫자가 양수인지, 음수인지 0인지를 구별한다.
				- MOD(숫자1, 숫자2) 숫자1을 숫자2로 나누어 나머지 값을 리턴					한다. %연산자로 대체 가능하다. EX) 숫자1%숫자2
				- CEIL/CEILING(숫자) 숫자보다 크거나 같은 최소의 정수를 리턴					한다.
				- FLOOR(숫자) 숫자보다 작거나 같은 최대의 정수를 리턴한다.
				- ROUND(숫자[,M]) 숫자를 소수점 M자리에서 반올림하여 리턴					한다. M이 생략되면 디폴트는 0이다.
				- TRUNC(숫자[,M]) 숫자를 소수 M자리에서 잘라서 버린다. M이 					생략되면 디폴트는 0이다.
				- SIN, COS, TAN(숫자) 숫자의 삼각함수 값을 리턴한다.
				- EXP, POWER, SQRT, LOG, LN(숫자) 숫자의 지수, 거듭제곱, 제					곱근, 로그, 자연로그 값을 리턴한다.


			날짜형 함수 - DATE 타입의 값을 연산한다.
			: SYSDATE/GETDATE, EXTRACT/DATEPART, 
			TO_NUMBER(TO_CHAR(D,'YYYY'|'MM'|'DD')/YEAR|MONTH|DAY
				- SYSDATE/GETDATE() 현재 날짜와 시간을 출력한다.
				- EXTRACT('YEAR'|''MONTH'|'DAY' FROM D)
				/ DATEPART('YEAR'|'MONTH'|'DAY',D) 날짜와 데이터에서 년/월/
				일 데이터를 출력 할 수 있다. 시간/분/초도 가능.
				-TO_NUMBER(TO_CHAR(D,'YYYY'))/YEAR(D) 
				 TO_NUMBER(TO_CHAR(D,'MM'))/MONTH(D)
				 TO_NUMBER(TO_CHAR(D,'DD'))/DAY(D) 날짜데이터에서 년/월/					일 데이터를 출력 할 수 있다. TO_NUMBER 제외시 문자형으로 					출력.
				- 날짜 + 숫자 -> 날짜. 숫자만큼의 날수를 날짜에 더한다.
				- 날짜 - 숫자 -> 날짜. 숫자만큼의 날수를 날쩨에서 뺀다.
				- 날짜1 - 날짜2 -> 날짜수. 다른 하나의 날짜에서 하나의 날자를 				뺀 일수가 나온다.
				- 날짜 + 숫자/24 -> 날짜. 시간을 날짜에 더한다.
			EX) SELECT SYSTEM FROM DUAL -> 12/07/18
				* DUAL TABLE : 사용자 SYS가 소유마여 모든 사용자가 액세스 					가능한 테이블. SELECT - FROM - 의 형태를 갖추기 위한 						DUMMY 테이블.
			SELECT GETDATE() AS CURRENTTIME 
				-> CURRENTTIME 2012-07-18 13:10:02.047
			SELECT DATEPART(YEAR, HIREDATE) AS 입사년도
				, DATEPART(MONTH, HIRETDATE) AS 입사월
				, DATEPART(DAY, HIREDATE) AS 입사일
			FROM EMP;
				-> EMP 테이블의 HIREDATE정보를 가져온다.


			변환형 함수 - 문자, 숫자, 날짜형 값의 데이터 타입을 변환한다.
			: TO_NUMBER, TO_CHAR, TO_DATE/CAST, CONVERT
				- 명시적(EXPLICIT) 데이터 유형 변환 : 데이터 변환형 함수로 데					이터 유형을 변환하도록 명시해 주는 경우.
				* CAST(EXPRESSION AS DATA_TYPE[(LENGTH)]) EXPRESSION을 				목표 데이터 유형으로 반환한다.
				* CONVERT(DATA_TYPE[(LENGTH)], EXPRESSION[,STYLE]) 
				EXPRESSION을 목표 데이터 유형으로 변환한다.
				EX) SELECT CONVERT(VARCHAR(10), GETDATE(), 111) AS 				CURRENTDATE -> 2012/07/19
				EX) 숫자형 변환 후 덧셈
					ZIP_CODE 데이터 : 700, 500, 800
					ZIP_CODE 데이터 : 50, 92, 40
				SELECT CAST(ZIP_CODE1 AS INT) + CAST(ZIP_CODE2 AS INT)
				FROM TEAM;
				-> 750, 592, 840

				-  암시적(IMPLICIT) 데이터 유형 변환 : 데이터베이스가 자동으로
				데티어 유형을 변환하여 계산하는 경우 -> 성능 저하가 발생할 					수 있으므로 자동으로 데이터베이스가 계산하지 않는 경우가 있					어 명시적인 데이터 유형 변환 방법을 사용하는 것이 바람직.
				
			CASE 표현 - IF-THEN-ELSE 논리와 유사한 방식으로 표현식을 작성하여 					SQL의 비교 연산 기능을 보완
				
				CASE
					SIMPLE_CASE-EXPRESSION 조건
					ELSE 표현절
				END
				-> SIMPLE_CASE_EXPRESSION 조건이 맞으면 SIMPLE_CASE_
				EXPRESSION 조건 내의 THEN 절을 수행하고, 조건이 맞지 않으					면 ELSE절을 수행한다. 조건에 사용되는 칼럼이나 표현식을 표시. 				EQUI 조건을 사용하지 않음.
				EX) SELECT LOC
					, CASE LOC WHEN 'NEW YORK' THEN 'EAST'
						WHEN 'BOSTON' THEN 'EAST'
						WHEN 'CHICAGO' THEN 'CENTER'
						WHEN 'DALLAS' THEN 'CENTER'
						ELSE 'ETC'
						END AS AREA
				FROM DEPT;

				CASE
					SEARCHED_CASE_EXPRESSION 조건
					ELSE 표현절
				END
				-> SEARCHED_CASE_EXPRESSION 조건이 맞으면 SEARCHED_
				CASE_EXPRESSION 조건 내의 THEN 절을 수행하고, 조건이 맞지 					않으면 ELSE 절을 수행한다. 칼럼이나 표현식을 사용하지 않고 					EQUI조건을 사용함.
				EX) SELECT ENAME
					, CASE WHEN SAL >= 3000 THEN 'HIGH'
						WHEN SAL >= 1000 THEN 'MID'
						ELSE 'LOW'
						END AS SALARY_GRADE
				FROM EMP;

				SELECT ENAME
					, SAL
					, CASE WHEN SAL >= 2000 THEN 1000
					ELSE (CASE WHEN >=1000 THEN 500
								ELSE 0
								END)
					END AS BONUS
				FROM EMP;


			NULL 관련 함수 - NULL을 처리하기 위한 함수
			: NVL/ISNULL, NULLIF, COALESCE
				값이 정해져 있지 않으므로 0, 공백, "" 와는 다르다.
				테이블 생성시 PK혹은 NOT NULL 컬럼 이외에 모든 데이터 유형				은 NULL값을 가질 수 있다.
				NULL값을 포함한 연산의 결과도 NULL이다.
				NULL 값이 아닌 값을 얻고자 할 때에는 NVL, ISNULL함수를 이용				해야 한다.
				칼럼 간 계산을 수행 하는 경우 NULL값이 존재하면 해당 연산 결				과가 NULL값이 되므로 원하는 데이터를 얻을 수 없고, 이런 경우					에 NVL 함수를 이용하여  0으로 변환을한 후 계산을 해서 원하는 					데이터를 얻는다.
				- NVL(표현식1, 표현식2)/ISNULL(표현식1,표현식2) 표현식1의 결				과값이 NULL이면 표현식 2의 값을 출력한다. 단, 표현식1과 표현					식2의 결과 데이터 타입이 같아야 한다. NULL 관련 가장 많이 사						용되는 함수이므로 상당히 중요하다.
				- NULLIF(표현식1, 표현식2) 표현식1이 표현식2와 같으면 NULL				을, 같지 않으면 표현식1을 리턴한다.
				- COALESCE(표현식1, 표현식2, ...) 임의의 개수 표현식에서 NULL				이 아닌 최초의 표현식을 나타낸다. 모든 표현식이 NULL이라면 					NULL을 리턴한다.

			EX) SELECT PLAYER_NAME 선수명
				, POSITION
				, ISNULL(POSITION, '없음') 포지션
			FROM PLAYER
			WHERE TEAM_ID = 'K08'

			-> CASE 문장으로 표현하면
			SELECT PLAYER_NAME 선수명
				, POSITION
				, CASE WHEN POSITION IS NULL THEN '없음'
					ELSE POSITION
					END  AS 포지션
			FROM PLAYER
			WHERE TEAM_ID = 'K08'

			NULL과 공집합
				데이터 조건이 한건도 없는 경우를 공집합이라 하지만 NULL값 				데이터와는 다르다.
				EX) SELECT MGR FROM EMP WHERE ENAME='KING';
				ENAME이 KING인 사람은 존재를 하나 MGR의 데이터 값이 없는 				경우에는 공집합에 해당하지 않는다.

				-> 공집합의 NVL/SINULL 함수 사용
				1) SELECT MGR FROM EMP WHERE ENAME='KANKAN';
				위의 데이터를 검색시 KANKAN의 이름을 가진 사람이 없는 경우				(데이터를 찾을 수 없는 경우) 이는 공집합에 해당한다.
				2) SELECT NVL((MGR),'9999') FROM EMP WHERE ENAME = 				'KANKAN';
				KANKAN의 이름을 가진 사람이 존재 하지 않으므로 데이터는 출				력 되지 않는다.
				3) SELECT NVL(MAX(MGR),'9999') FROM EMP WHERE ENAME = 				'KANKAN';
				MAX의 값으로 검색을 할 경우 ENAME에서 KANKAN의 이름을 					가진 사람이 없더라도 MAX그룹 합수를 이용하여 NULL값을 출					력하였다.
				(1개의 레코드를 출력.) 그 후NULL값을 NVL로 이용하여 9999로 					치환하였으므로 '9999;가 출력 되었다.
			
			NULLIF 
				NULLIF 함수는 EXPR1이 EXPR2와 같으면 NULL을, 같지 않으면 				EXPR1을 리턴한다.

			기타 NULL함수 (COALESCE)
				COALESCE함수는 인수의 숫자가 한정되어 있지 않으면, NULL이 				아닌 최초의 EXPR을 나타낸다. 만일 모든 EXPR이 NULL이면 					NULL을 리턴한다.
				EX)SELECT ENAME, COMM, SAL, COALESCE(COMM,SAL) COAL 				FROM EMP;
				-> COMM값이 NULL이면 SAL을 비교하여 SAL값도 NULL인 경				우 NULL를 리턴한다. 단 NULL값이 아닌 경우는 해당 컬럼의 값					을 리턴한다. 

		단일행 함수의 특징 -> SELECT, WHERE, ORDER BY 절에서 사용 가능.
			각 행들에 대해서 개별적으로 작용하여 데이터 값들을 조작하고, 각각 행에 			대한 조작 결과를 리턴한다.
			여러 인자를 입력해도 하나의 결과만 리턴한다.
			함수의 인자로 상수, 변수, 표현식이 사용 가능하고, 하나의 인수를 가지는
			경우도 있지만 여려 개의 인수를 가질 수도 있다.
			특별한 경우가 아니면 함수의 진자로 함수를 사용하는 함수의 중첩이 가능				하다.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
		다중행 함수 - 여러 행들의 그룹이 모여서 그룹당 단 하나의 결과를 돌려준다.
			집계 함수 
				GROUP BY 절은 행들을 소그룹화 한다.
				SELECT절, HAVING절, ORDER BY절에 사용 가능하다.
			집계 함수명 ( DISTINCT 칼럼이나 표현식)
				ALL : DAFAULT 옵션으로 생략 가능
				DISTINCT : 같은 값을 하나의 데이터로 간주할 때 사용하는 옵션
			
				* 자주 사용되는 주요 집계함수
				COUNT(*) NULL값을 포함한 행의 수를 출력.
				COUNT(표현식) 표현식의 값이 NULL 값인 것을 제외한 행의 수				를 출력.
				SUM([DISTINCT|ALL]표현식) 표현식의 NULL값을 제외한 합계를 				출력.
				AVG([DISTINCT|ALL]표현식) 표현식의 NULL값을 제외한 평균을 				출력.
				MAX([DISTINCT|ALL]표현식) 표현식의 최대값을 출력.(문자, 날짜 				데이터 타입도 가능)
				MIN([DISTINCT|ALL]표현식) 표현식의 최소값을 출력.
				STDDEV([DISTINCT|ALL]표현식) 표현식의 표준편차를 출력.
				VARIAN(DISTINCT|ALL]표현식) 표현식의 분산을 출력.

		GROUP BY 절 
			* 형식
			SELECT [DISTINCT] 칼럼명 [ALIAS명]
			FROM 테이블명
			[WHERE 조건식]
			[GROUP BY 칼럼이나 표현식]  -> 소그룹화
			[HAVING 그룹조건식]   -> 만족하는 조건 거르기

			* 특징 - GROUP BY 절을 통해 소그룹별 기준을 정한 후, SELECT 절에 집계			함수를 사용
			집계 함수의 통계 정보는 NULL 값을 가진 행을 제외하고 수행
			GROUP BY 절에서는 SELECT 절과 달리 ALIAS명을 사용할수 없다.
			집계 함수는 WHERE 절에는 올 수 없다.
			WHERE 절은 전체 데이터를 GROUP 으로 나누기 전에 행들을 미리 제거
			HAVING절은 GROUP BY 절의 기준 항목이나 소그룹의 집계 함수를 이용한 			조건을 표시 할 수 있다.
			GROUP BY 절에 의한 소그룹별로 만들어진 집계 데이터 중, HAVING 절에			서 제한 조건을 두어 조건을 만족하는 내용만 출력한다.
			HAVING 절은 일반적으로 GROUP BY 절 뒤에 위치한다.

			원칙적으로 관계형 데이터베이스 환경에서는 ORDER BY 절을 명시해야 데			이터 정렬이 수행된다.
		
		HAVING 절
			
			* WHERE 절에서는 집계함수가 허용되지 않는다.
			EX) 포지션 별로 평균키가 180인 사람에 대해 출력하기
			
			SELECT POSITION             포지션  
   			  , ROUND(AVG(HEIGHT),2) 평균키  
 			 FROM PLAYER  
 			WHERE AVG(HEIGHT) >= 180          
 			GROUP BY POSITION;   

			* - - * 3행에 오류: ERROR: 집계 함수는 허가되지 않는다.*  

			수정 후

			SELECT POSITION             포지션  
  			   , ROUND(AVG(HEIGHT),2) 평균키  
  			FROM PLAYER  
			 GROUP BY POSITION;  
			HAVING AVG(HEIGHT) >= 180  

		CASE를 이용한 데이터 집계

			집계함수 (CASE()) ~ GROUP BY 기능은 모델링의 제1정규화로 인해 반복			되는 칼럼의 경우 구분 칼럼을 두고 여러개의 레코드로 만들어진 집합을, 			정해진 칼럼 수만큼 확장해서 집계 보고서를 만드는 유용한 기법이다.

			EX) 부서별로 월별 입사자의 평균 급여를 알고 싶다는 고객의 요구사항이 				있는데, 입사 후 1년마다 급여 인상이나 보너스 지급과 같은 일정이 정기적				으로 잡힌다면 업무적으로 중요한 정보가 될 수 있다.
			
			STEP1) 월별 데이터를 추출하는 작업을 진행한다. 이 단계는 월별 정보가 			있다면 생략 가능하다.
			SELECT ENAME, DEPTNO, DATEPART(MONTH, HIREDATE) AS 입사월
			
			STEP2) 월별 데이터 구분
			SELECT ENAME, DEPTNO,
				CASE MONTH WHEN 1 THEN SAL END M01,
				CASE MONTH WHEN 2 THEN SAL END M02, ....
			FROM 
				( SELECT ENAME,
					DEPTNO,
					EXTRACT (MONTH FROM HIREDATE) MONTH,
					SAL
				FROM EMP)
			;

			STEP 3) 부서별 데이터 집계
			SELECT DEPTNO,
				AVG(CASE MONTH WHEN 1 THEN SAL END) M01,
				AVG(CASE MONTH WHEN 2 THEN SAL END) M02, ...
			FROM 
				(
				SELECT ENAME,
					DEPTNO,
					EXTRACT(MONTH FROM HIREDATE0 MONTH,
					SAL
				FROM EMP
				)
			GROUP BY DEPTNO

			-> 하나의 데이터에 여러번의 CASE를 쓴것이 SQL처리 성능 측면에서 나			쁘다고 생각 될 수 있지만 같은 기능을 하는 리포트를 작성하기 위해 장문			의 코딩을 하는 것에 비해, 위의 방법을 사용하면 복잡한 프로그램이 아닌 			하나의 SQL 문장으로 처리 가능하므로 DBMS 자원 활용이나 처리 속도에			서 훨씬 효율적이다. 데이터의 건수가 많아질수록 처리 속도의 차이는 커진			다.

		집계함수와 NULL
			리포트의 빈칸을 NULL이 아닌 ZERO로 표현하기 위해 NVL, ISNULL함수를 			사용하는 경우가 많은데, 다중 행 함수를 사용하는 경우는 오히려 불필요한 			부하가 발생하므로 굳이 NVL 함수를 다중 행 함수 안에 사용할 필요가 없			다.
			다중 행 함수는 입력 값으로 전체 건수가 NULL값인 경우만 함수의 결과가 			NULL이 나오고 전체 건수 중에서 일부만 NULL인 경우는 NULL행을 다중 			행 함수의 대상에서 제외한다.
			SUM(CASE MONTH WHEN 1 THEN SAL ELSE 0 END) 처럼 ELSE 정에서 0			(ZERO)를 지정하면 불필요하게 0이 SUM 연산에 사용되므로 자원의 사용			이 많아진다.

			SUM은 NULL값을 제외하고 합산하므로 NVL/ISNULL을 사용 할 때에는 			SUM 밖에서 사용하는 것이 자원의 낭비를 줄왼다.

		ORDER BY 정렬
			ORDER BY 절은 SQL문장으로 조회된 데이터들을 다양한 목적에 맞게 특정 			칼럼을 기준으로 정렬하여 출력하는데 사용한다.
			ORDER BY 절에 컬럼 명 대신에 SELECT정에서 사용한 ALIAS 명이나 칼럼 			순서를 나타내는 정수도 사용 가능하다.
			별도로 정렬 방식을 지정하지 않으면 기본적으로 오름차순이 적용되며, 			SQL문장의 제일 마지막에 위치한다.
			
			SELECT 칼럼명 [ALIAS명]
			FROM 테이블명
			[WHERE 조건식]
			[GROUP BY 칼럼이나 표현식]
			[HAVING 그룹조건식]
			[ORDER BY 칼럼이나 표현식 [ASC 또는 DESC]]; -> ASC : 오름차순으로 정			렬(DEFAULT) DESC : 내림차순으로 정렬

			EX) SELECT PLAYER_NAME 선수명,
				POSITION 포지션,
				BACK_NO 백넘버
			FROM PLAYER
			ORDER BY 포지션 ASC;
			= ORDER BY 2
			= ORDER BY POSITION
			-> 포지션이 NULL값인 경우 : NULL값이 맨 앞으로 온다. 가장 작은 값으로 			간주

		SELECT 문장 실행 순서
			SELECT 칼럼명 [ALIAS]
			FROM 테이블명
			WHERE 조건식
			GROUP BY 칼럼이나 표현식
			HAVING 그룹조건식
			ORDER BY 칼럼이나 표현식;

			1. 발췌 대상 테이블을 참조한다 -> FROM
			2. 발췌 대상 데이터가 아닌것을 제거한다. -> WHERE
			3. 행들을 소그룹화 한다. -> GROUP BY
			4. 그룹핑된 값의 조건에 맞는 것만을 출력한다. -> HAVING
			5. 데이터 값을 출력 및 계산 한다. -> SELECT
			6. 데이터를 정렬한다. -> ORDER BY

			-> 옵티마이저가 SQL 문장의 SYNTAX, SEMANTIC 에러를 점검하는 순서이				자 실행 순서.
			FROM 절에 정의되지 않은 테이블의 컬럼을 WHERE 절, GROUP BY 절, 				HAVING 절, SELECT 절, ORDER BY 절에 사용하면 에러가 발생한다. 그러나 			ORDER BY 절에는 SELECT 목록에 나타나지 않은 문자형 항목이 포함될 수 				있다.
			단 SELECT DISTINCT를 지정하거나 SQL 문장에 GROUP BY 절이 있거나, 				SELECT 문에 UNION 연산자{}가 있으면 열 정의가 SELECT 목록에 표시{}되				어야 한다.
		
			-> GROUP BY 절에서 그룹핑 기준을 정의하게 되면 데이터베이스를 일반				적으로 SELECT 문장처럼 FROM 절에 정의된 테이블의 구조를 그대로 가지				고 가는 것이 아니라, GROUP BY 절의 그룹핑 기준에 사용된 컬럼과 집계 				함수에 사용될 수 있는 숫자형 데이터 칼럼들의 집합을 새로 만든다.
			GROUP BY 절을 사용하게 되면 그룹핑 기준에 사용된 칼럼과 집계 함수에 			사용될 수 있는 숫자형 데이터 칼럼들의 집합을 새로 만드는데, 개별 데이			터는 필요 없으므로 저장하지 않는다.
			GROUP BY 이후 수행 절인 SELECT 절이나 ORDER BY 절에서 개별 데이터			를 사용하는 경우 에러가 발생한다.
			SELECT 절에서는 그룹핑 기준과 숫자 형식 칼러므이 집계 함수를 사용할 			수 있지만, 그룹핑 기준 외의 문자 형식 칼럼은 정할 수 없다.
			
			-> ************** 이해안감.

			-> http://www.gurubee.net/lecture/2374
			GROUP BY 사용시 ORDER BY 절에 일반 칼럼을 쓸수 없다. 집계함수와 같				은 함수가 와야 한다. ?????????????????????????????/

			-> GROUP BY 절이 사용되었기 때문에 SELECT 절에 정의하지 않은 MAX, 			SUM, COUNT 집계 함수도 ORDER BY 절에서 사용할 수 있음

		TOP N 쿼리
			ROWNUM : 데이터의 일부가 먼저 추출된 후 데이터에 대한 정렬 작업이 			일어남. WHERE절이 먼저, 그다음 ORDER BY절

			WHERE -> SELECT -> ORDER BY

			1) 4건의 먼저 추출 한 뒤 정렬이 일어남.
			SELECT 	ENAME,
				SAL
			FROM 	EMP
			WHERE 	ROWNUM < 4
			ORDER BY SAL DESC;

			-> 테이블에서 행을 4개로 자른뒤 정렬

			2) 먼저 데이터를 정렬하고 4건의 데이터만 가져오는 경우
			SELECT 	ENAME,
				SAL
			FROM	(
				SELECT  ENAME,
					SAL
				FROM  EMP
				ORDER BY SAL DESC
				)
			WHERE ROW NUM < 4  ( == LIMIT (0,4) )

			-> 정렬된 데이터를 가져와서 4건만 추출

			3) TOP N 쿼리 : 데이터 정렬 작업 후에 추출 작업이 일어남.
			SELECT 	TOP(4)
				ENAME,
				SAL
			FROM EMP
			WHERE ROWNUM < 4
			ORDER BY SAL DESC;	

			-> ORDER BY 절이 없다면 ROW NUM과 TOP의 기능은 같다.
			하지만 정렬이 일어나게 되면 SELECT 문장의 실행 순서에 다라 전혀 다른 				방식으로 출력하게 된다.
////////////////////////////////////////////////////////////////////////////////////////////////////////////

		* JOIN 
			두개 이상의 테이블 들을 연결 또는 결합 하여 데이터를 출력하는 것. 관계			형 데이터베이스의 가장 큰 장점이며 핵심 기능이다. 일반적인 경우 행들은 			PRIMARY KEY 또는 FOREIGH KEY 값의 연관에 의해 JOIN이 성립된다. 어떤 			경우에는 관계가 없어도 논리적인 값들의 연관 만으로도 성립 가능하다.
			FROM 절에  여러 테이블이 나열되더라도 SQL에서 데이터를 처리할 때는 			단 두개의 집합간에만 조인이 일어난다.
			FROM 절에 A,B,C 테이블이 나열된 경우 특정 2개의 테이블만 먼저 조인 			처리되고, 2개의 테이블이 조인되어 처리된 새로운 데이터 집합과 남은 한			개의 테이블이 다음 차례에 조인되는 식이다.
		
		-> EQUAL JOIN
			두개의 테이블 간에 칼럼 값들이 서로 정확하게 일치하는 경우에 사용되는 			방법으로 대부분 PK <-> FK의 관게를 기반으로 한다.
			일반적으로 테이블 설계시에 나타난 PK<->FK 관계를 이용하는 것이지 반			드시 이 관계로만 EQUAL JOIN이 성립하는 것은 아니다.
			이 기능은 계층형(HIERARCHICAL)이나 망형(NETWORK) 데이터베이스와 비			교해서 관계형 데이터베이스의 큰 장점이다.

			EX) WHERE 안에 사용한 JOIN
			SELECT	테이블1.칼럼명, 테이블2.칼럼명, ...
			FROM 	테이블1
			INNER JOIN 테이블2
			ON 테이블1.칼럼명1 = 테이블2.칼럼명2;  ->  JOIN 조건을 넣는다.

			-> 테이블명.칼럼명 과 같이 테이블명과 칼럼명을 같이 명시
			특정 칼럼에 접근하기 위해 그 칼럼이 어느 테이블에 존재하는 칼럼인지를 			명시. JOIN에 사용되는 두개의 테이블에 같은 칼럼명이 존재하는 경우 파				싱 단계에서 에러가 발생한다.  SQL에 대한 가독성이나 유지보수성을 높이				는 효과가 있다.
			하나의 SQL 문장 내에서 유일하게 사용하는 칼럼명이라면 칼럼명 앞에 테				이블 명을 붙이지 않아도 되지만, 향후 발생할 오류를 방지하고 일관성을 				위해 앞에 테이블명을 붙여서 사용하는 것이 좋다.
			ALIAS를 지정 하였으나 테이블 명을 사용 할 경우 오류가 발생한다.

			-> NON EQUAL JOIN
			연산자가 아닌 다른 (BETWEEN, <=, >=, <, >)연산자를 사용하여 JOIN을 			수행한다. 
			두개의 테이블이 PK-FK 연관관계를 가지거나 논리적으로 같은 값이 존재			하는 경우에는 "=" 연산자를 이용하여 EQUI JOIN을 사용한다.
			그러나 두개의 테이블 간에 칼럼 값들이 서로 정확하게 일치하지 않는 경			우에는 EQUI JOIN을 사용할 수 없으며 NON EQUAL JOIN을 사용 할 수 있			으나 모델링에 따라 사용하지 못하는 경우가 있다.
	
			EX) 
			SELECT 	E.NAME,
				E.JOB,
			E.SAL,
			S.GRADE
			FROM EMP E, SALGRADE S
			WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;

			-> CASE를 이용한 코딩과 차이는???

		3개 이상의 TABLE JOIN
			데이터의 정합성에 따라서 데이터를 분할하여 생성.
			성능 측면에서도 간단한 데이터를 조회하는 경우에도 규모가 큰 테이블에				서 필요한 데이터를 찾아야 하기 때문에 검색 속도가 떨어질 수 있다.
			테이블을 정규화 하여 데이터를 분할하여 해결 할 수 있다.
			특정 요구조건을 만족하는 데이터들을 분할된 테이블로 부터 조회하기 위				해서는 테이블 간에 논리적인 연관관계가 필요하고, 그런 관계성을 통해 다				양한 데이터들을 출력 할 수 있다.
			이런 논리적인 관계를 구체적으로 표현하는 것이 SQL 문장에서 JOIN의 조				건이다.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////

	표준 조인
		STANDARD SQL
			- STANDARD JOIN 기능 : CROSS JOIN, OUTER JOIN등의 새로운 FROM절 JOIN 기능
	- SCALAR SUBQUERY, TOP-N QUERY 등의 새로운 SUBQUERY 기능
	- ROLLUP, CUBE, GROUPING SETS 등의 새로운 리포팅 기능
	-WINDOW FUNCTION 같은 새로운 개념 분석 기능

	일반 집합 연산자 -> 두개 이상의 집합(SELECT의 결과) 에 더해서 서로 더하거나 빼는 등의 연산을 수행. 테이블에서 추출하는 컬럼의 수와 데이터 타입이 일치해야 사용가능.
		UNION : 합집합. 공통 교집합의 중복을 없애기 위해 사전 작업으로 정렬작업
		UNION ALL : 공통집합 그대로 보여준다. 중복행을 그대로 표시
	INTERSECTION : 교집합. 중복행은 한번만 출력.
	DIFFERENCE/EXCEPT : 차집합. 중복행은 한번만 출력.
	PRODUCT : CROSS PRODUCT라 불리는 곱집합.
		EX) (A,B,C) * (X,Y) -> AX, AY, BX, BY, CX, CY

	순수 관계 연산자 -> 관게형 데이터베이스를 구현하기 위해 새롭게 만들어진 연산자
		SELECT : WHERE 절로 구현(행으로 뽑기)
	PROJECT : SELECT 절로 구현(열로 뽑기)
	(NATURAL) JOIN : 다양한 JOIN으로 구현. WHERE 절의 INNER JOIN 조건과 함께 FROM 절의 NATURAL JOIN, INNER JOIN, OUTER JOIN, USING 조건절, ON 조건절 등
	DIVIDE : 현재 사용되지 않음.
		EX) (AX, AY, AZ, BX, CY) -> (X,Y) (A)

	-> ****** 관계형 데이터베이스의 경우 요구사항 분석, 개념적 데이터 모델링, 논리적 데이터 모델링, 물리적 데이터 모델링 단계를 거치는데, 이 단계에서 엔터티(실체, 객체-정보가 될 수 있는 개념) 확정 및 정규화 과정, 그리고 M:M(다수대 다수) 관계를 분해하는 절차를 거치게 된다.
정규화 과정의 경우 데이터 정합성과 데이터 저장 공간의 절약을 위해 엔터티를 최대한 분리하는 작업으로, 일반적으로 3차 정규형니아 보이스코드 정규형까지 진행하게 된다. 이런 정규화를 거치면 하나의 주제에 관련 있는 엔터티가 여러 개로 나누어지게 되고, 이 엔터티들이 주로 테이블이 되는데 이렇게 흩어진 데이터를 연결해서 원하는 데이터를 가져오는 작업이 바로 JOIN이라고 할 수 있다.

	FROM 절의 JOIN 형태
		1) INNER JOIN - OUTER JOIN과 대비하여 내부 JOIN 이라고 하며 JOIN 조건에서 동일한 값이 있는 행만 반환한다.
INNER JOIN 표시는 그 동안 WHERE 절에서 사용하던 JOIN 조건을 FROM 절에서 정의하겠다는 표시이므로 USING 조건절이나 ON 조건절을 필수적으로 사용해야 한다.

		SELECT A.DEPT, A.EMPNO, A.NAME, B.DNAME
		FROM EMP A, DEPT B
		WHERE A.DEPTNO = B.DEPTNO;

		SELECT A.DEPT, A.EMPNO A.NAME, B.NAME
		FROM EMP A (INNER) JOIN DEPT B
		WHERE A.DEPTNO = B.DEPTNO;

		위의 두 쿼리는 같은 결과를 반환한다.


		2) NATURAL JOIN - NATURAL JOIN은 두 테이블 간의 동일한 이름을 갖는 모든 칼럼들에 대해 EQUI(=) JOIN을 수행한다. NATURAL JOIN이 명시되면, 추가로 USING 조건절, ON 조건절, WHERE 조건절에서 JOIN 조건을 정의할 수 없다.
	
		SELECT DEPTNO, EMPNO, ENAME, DNAME
		FROM EMP NUTURAL JOIN DEPT;


		3) USING 조건절 - NATURAL JOIN에서는 모든 일치되는 컬럼들에 대해서 JOIN이 이루어 지지만, FROM 절의 USING 조건절을 이용하면 같은 이름을 가진 칼럼들 중에서 원하는 칼럼에 대해서만 선택적으로 EQUI JOIN을 할 수가 있다.

	EX) 
		SELECT *
		FROM DEPT JOIN DEPT_TEMP
		USING (DEPTNO); / USING (LOC,DEPTNO);
		-> USING절에 명시된 컬럼이 기준이 되어 동일한 열들을 조인한다. 명시된 데이터가 앞에 나온다.


		4) ON 조건절 - JOIN 서술부(ON 조건절)와 비 JOIN TJTNFQN(WHERE 조건절)을 분리하여 이해가 쉬우며, 칼럼의 명이 다르더라도 JOIN을 사용할 수 있다는 장점이 있다.
	EX) WHERE 절과의 혼용
	SELECT E.EMPNO, E.NAME, E.DEPTNO, D.DNAME
	FROM EMP E JOIN DEPT D
	ON E.DEPTNO = D.DEPTNO
	WHERE E. DEPTNO = 30;

	ON 조건절 + 데이터 검증 조건 추가
	SELECT E.EMPNO, E.NAME, E.DEPTNO, D.DNAME
	FROM EMP E JOIN DEPT D
	ON (E.DEPTNO = D.DEPTNO AND E.DEPTNO = 30);
	-> 위의 예제와 같은 값이 반환

	다중 테이블 JOIN
	SELECT E.EMPNO, D.DEPTNO, D.DNAME, T.DNAME NEW_NAME
	FROM EMP JOIN D
	ON (E.DEPTNO  = D.DEPTNO)
	JOIN DEPT_TEMP T
	ON (E.DEPTNO = T.DEPTNO);

	SELECT E.EMPNO, D.DEPTNO, D.DNAME, T.DNAME NEW_NAME
	FROM EMP E, DEPT D, DEPT_TEMP T
	WHERE (E.DEPTNO = D.DEPTNO) AND (E.DEPTNO = T.DEPTNO);


		5) CROSS JOIN - CROSS JOIN은 일반 집합 연산자의 PRODUCT 개념으로 테이블 간 JOIN 조건이 없는 경우 생길 수 있는 모든 데이터의 조합을 반환한다. 두 개의 테이블에 대한 CROSS PRODUCT와 같은 표현으로, 결과는 M*N 건의 데이터 조합이 발생한다.

	EX) SELECT ENAME, DNAME
	FROM EMP CROSS JOIN DEPT
	ORDER NY NAME;

		6) OUTER JOIN - INNER JOIN과 대비하여 OUTER JOIN이라 불리며, JOIN 조건에서 동일한 값이 없는 행도 반환할 때 사용할 수 있다.

		LEFT OUTER JOIN 
		RIGHT OUTER JOIN
		FULL OUTER JOIN

		EX)
		SELECT *
		FROM EMP E [FULL] OUTER JOIN DEPT D
		ON E.DEPTNO = D.DEPTNO;

		는 다음 쿼리와 같은 결과를 출력한다.
		SELECT *
		FROM EMP E LETF OUTER JOIN DEPT D
		ON E.DEPTNO = D.DEPTNO
		UNION
		SELECT *
		FROM EMP E RIGHT OUTER JOIN DEPT D
		ON E.DEPTNO = D.DEPTNO;
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

	집합 연산자 - 두개 이상의 테이블에서 조인을 사용하지 않고 연관된 데이터를 조회하는 방법 중에 도 다른 방법이 있는데 그 방법이 바로 집합 연산자(SET OPERATEO)를 사용하는 방법이다.

	UNION 여러 개의 SQL문의 결과에 대한 합집합으로 결과에서 모든 중복된 행은 하나의 행으로 만든다.
	UNION ALL 여러 개의 SQL문의 결과에 대한 합집합으로 중복된 행도 그대로 결과로 표시된다. 즉 단순히 결과만 합쳐 놓은 섭이다. 일반적으로 여러 개의 결좌가 상호 배타적인(EXCLUSIVE)한 경우에 많이 사용한다. 
	INTERSECT 여러 개의 SQL 문의 결과에 대한 교집합이다. 중복된 행은 하나의 행으로 만든다.
	EXCEPT/MINUS 앞의 SQL문의 결과에서 뒤의 SQL 문의 결과에 대한 차집합이다. 중복된 행은 하나의 행으로 만든다.

	EX) R1(1,1,1,2,2,3,3,5) R2(1,1,2,2,2,3,4)
	-> UNION ONLY R1(5) INTERSECTIOIN(1,2,3) ONLY R2(4)
	    UNION ALL R1(1,1,1,2,2,3,3,5) R2(1,1,2,2,2,3,4)
	    INTERSECTION(1,2,3)
	    EXCEPT(5)

	-> 정렬 할꺼면 ORDER BY 사용.
	ORDER BY 칼럼 번호.

/////////////////////////////////////////////////////////////////////////////////////////////////////////

	계층형 질의와 셀프 조인
		계층형 질의 - 테이블에 계층형의 데이터가 존재하는 경우 데이터를 조회하기 위해서 게층형 질의를 사용한다. (HIERARCHICAL QUERY)
게층형 데이터란 동일 테이블에 게층적으로 상위와 하위 데이터가 포함괸 데이터를 말한다.
1) 순환관계 데이터 모델 -> 사원중에 관리자 사원이 있어 같은 사원을 관리.
2) 계층형 구조. A의 하위사원은 B,C이고 B의 밑에는 하위 사원이 없고 C의 하위사원은 D,E가 있다.
3) 이를 표로 나타내면
	사원	관리자
	A	
	B	A
	C	A
	D	C
	E	C

WITH 	(앵커 멤버(ANCHOR MEMBER)
	UNION ALL
	재귀 멤버(RECURSIVE MEMBER)
	)
SELECT 
FROM

WITH절의 CTE 쿼리 (COMMOM TABLE EXPRESSION)를 보면 UNION ALL 연산자를 이용해 두개를 결합하였다. 
위의 쿼리를 앵커 멤버라고 하고, 아래의 쿼리를 재귀 멤버라고 한다.
재귀적 쿼리를 처리하는 과정은 다음과 같다.
	CTE식을 앵커 멤버와 재쉬 멤버로 분할한다.
	앵커 멤버를 실행하여 첫 번재 호출 또는 기본 결과 집합(T0)를 만든다.
Ti는 입력으로 사용하고 Ti+1은 출력으로 사용하여 재귀 멤버를 실행한다.
빈 집합이 반환될 대가지 3단계를 반복한다.
결과집합을 반환한다. 이것은 T0에서 Tn까지의 UNION ALL이다.

셀프 조인
	셀프 조인이란 동일한 테이블 사이의 조인으로 FROM 절에서 동일 테이블이 두번 이상 나타난다.
	동일 테이블 사이의 조인을 수행하면 테이블과 칼럼 이름이 모두 동일하기 때문에 식별을 위해 반드시 테이블 별칭(ALIAS)를 사용해야 한다.
	칼럼에도 모두 별칭을 사용해서 어느 테이블의 칼럼인지 식별해줘야 한다.

////////////////////////////////////////////////////////////////////////////////////////////////////////////

	서브 쿼리 -> 하나의 SQL 문 안에 포함되어 있는 또 다른 SQL문을 말한다. 알려지지 않은 기준을 이용한 검색을 위해 사용한다. 메인쿼리 안에 서브쿼리가 포함된 종속적인 관계이다.
		서브쿼리는 괄호로 감싸서 사용한다.
		단일 행 또는 복수행 비교 연산자와 함께 사용 가능하다. 단일 행 비교 연산자는 서브쿼리의 결과가 반드시 1건 이하이여야 하고 복수 행 비교 연산자는 서브쿼리의 결과 건수가 상관 없다.
		서브 쿼리에서는 ORDER BY를 사용하지 못한다. ORDER BY 절은 SELECT 절에서 오직 한개만 올수 있기 때문에 메인쿼리의 마지막 문장에 위치해야 한다.

	사용 가능한 곳
		SELECT 절
		FROM 절
		WHERE 절
		HAVING 절
		ORDER BY 절
		INSERT VALUES 절
		UPDATE SET 절

UN-CORRELATED(비연관) 서브쿼리 - 서브쿼리가 메인쿼리 컬럼을 가지고 있지 않은 형태의 서브쿼리이다. 메인쿼리에 값(서브쿼리가 실행된 결과)을 제공하기 위한 목적으로 주로 사용한다.
CORRELATED(연관) 서브쿼리 - 서브쿼리가 메인쿼리 컬럼을 가지고 있는 형태의 서브쿼리이다. 일반적으로 메인 쿼리가 먼저 수행되어 읽혀진 데이터를 서브쿼리에서 조건이 맞는지 확인하고자 할 때 주로 사용된다.

SINGLE ROW 서브쿼리(단일 행 서브쿼리) - 서브쿼리의 실행 결과가 항상 1건 이하인 서브 쿼리를 의미한다. 단일 행 서브쿼리는 단일 행 비교 연산자와 함께 사용된다. 단일 행 비교 연산자에는 =, <, >, <=, >=, <> 이 있다.
MULTI ROW 서브쿼리(다중 행 서브쿼리) - 서브쿼리의 실행 결과가 여러 건인 서브 쿼리를 의미한다. 다중 행 서브쿼리는 다중 행 비교 연산자와 함께 사용된다. 자중 행 비교 연산자에는 IN, ALL, ANY, SOME, EXISTS가 있다.
MULTI COLUMN 서브쿼리(다중 컬럼 서브쿼리) - 서브쿼리의 실행 결과로 여러 컬럼을 반환한다. 메인쿼리의 조건절에 여러 컬럼을 동시에 비교할 수 있다. 서브쿼리와 메인쿼리에서 비교하고자 하는 컬럼 개수와 컬럼의 위치가 동일해야 한다.

- 단일행 서브 쿼리
	EX) 정남일 선수가 소속된 팀의 정보를 알고 싶을 때
	-> SELECT *
	FROM PLAYER
	WHERE TEAM_ID = "정남일 선수가 소속된 팀코드"
			-> SELECT TEAM_ID
			FROM PLAYER
			WHERE PLAYER_NAME = '정남일'

	-> SELECT PLAYER_NAME 선수명
		, POSITION 포지션
		, BACK_NO 백넘버
	FROM PLAYER
	WHERE TEAM_ID = 
			( SELECT TEAM_ID
			FROM PLAYER
			WHERE PLAYER_NAME = '정남일'
			)
	ORDER BY PLAYER_NAME;

	EX) 평균 키보다 작은 선수들에 대한 정보를 얻고 싶을 때
	-> SELECT *
	FROM PLAYER
	WHERE HEIGHT <= 선수들의 평균키
			-> SELECT AVG(HEIGHT)
			FROM PLAYER

	-> SELECT *
	FROM PLAYER
	WHERE HEIGHT <=	( SELECT ABG(HEIGHT)
			FROM PLAYER)
	ORDER BY PLAYER_NAME;

- 다중 행 서브쿼리
	IN : 서브쿼리의 결과에 존재하는 임의의 값과 동일한 조건을 의미한다.
	비교연산자 ALL : 서브쿼리의 결과에 존재하는 모든 값을 만족하는 조건을 의미한다. 비교 연산자로 ">"를 사용했다면 메인쿼리는 서브쿼리의 모든 결과 값을 만족해야 하므로, 서브쿼리 결과의 최대값보다 큰 모든 건이 조건을 만족한다.
	비교연산자 ANY/SOME : 서브쿼리의 결과에 존재하는 어느 하나의 값이라도 만족하는 조건을 의미한다. 비교 연산자 ">"를 사용했다면 메인쿼리는 서브쿼리의  값들 중 어떤 값이라도 만족하면 되므로, 서브쿼리의 결과의 최소값보다 큰 모든 건이 조건을 만족한다.
EXISTS : 서브쿼리의 결과를 만족하는 값이 존재하는지 여부를 확인하는 조건을 의미한다. 조건을 만족하는 건이 여러 건이더라도 1건만 찾으면 더 이상 검색하지 않는다.

-> 서브쿼리에서 반환하는 값이 2개 이상인 경우 = 대신에 IN을 사용해야 한다.

- 다중 컬럼 서브쿼리 - 다중 컬럼 서브쿼리는 서브쿼리의 결과로 여러 개의 컬럼이 반환되어 메인쿼리의 조건과 동시에 비교되는 것을 의미한다. ???????????????????????????????????
	EX) SELECT TEAM_ID 팀코드,
		PLAYER_NAME 선수명,
		POSITION 포지션,
		BACK_NO 백넘버,
		HEIGHT 키
	FROM PLAYER
	WHERE (TEAM_ID, HEIGHT) IN
				( SELECT  TEAM_ID, MIN(HEIGHT)
				FROM PLAYER
				GROUP BY TEAM_ID)
	ORDER BY TEAM_ID, PLAYER_NAME;

- 연관 서브쿼리 - 연관 서브쿼리(CORRELATED SUBQUERY)는 서브쿼리 내에 메인쿼리 칼럼이 사용된 서브쿼리이다.

	EX) 	SELECT 	T.TEAM_NAME 팀명,
			M.PLAYER_NAME 선수명,
			M.POSITION 포지션,
			M.BACK_NO 백넘버,
			M.HEIGHT 키
		FROM PLAYER M, TEAM T
		WHERE M.TEAM_ID = T.TEAM_ID
		AND M.HEIGHT <	( SELECT 	AVG(S.HEIGHT)
				FROM PLAYER S
				WHERE S.TEAM_ID = M.TEAM_ID
				AND S.HEIGHT IS NOT NULL
				GROUP BY S.TEAM_ID )
		ORDER BY 선수명;

- 그 밖의 위치에서 사용하는 서브쿼리
	SELECT 절에 서브쿼리 사용하기.
	-> SELECT 절에서 사용하는 서브 쿼리인 스칼라 서브쿼리.
	한 행, 한 컬럼만을 반환하는 서브쿼리를 말한다.
	스칼라 서브쿼리는 칼럼을 쓸 수 있는 대부분의 곳에서 사용할 수 있다.

	EX) 선수 정보와 해당 선수가 속한 팀의 평균 키를 함께 출력하기
	SELECT PLAYER_NAME 선수명, HEIGHT 키, 소속팀의 평균키
	FROM PLAYER P			

	소속팀의 평균 키 -> 	SELECT AVG(HEIGHT)
				FROM PLAYER X
				WHERE X.TEAM_ID = P.TEAM_ID

	SELECT 	PLAYER_NAME 선수명,
		HEIGHT 키,
		( SELECT	AVG(HEIGHT)
		FROM PLAYER X
		WHERE X.TEAM_ID = P.TEAM_ID) 팀평균키
	FROM PLAYER P;

- FROM 절에서 서브쿼리 사용하기
	FROM 절에서 사용되는 서브쿼리를 인라인 뷰(INLINE VIEW)라고 한다.
	인라인 뷰는 테이블 명이 올 수 있는 곳에서 사용할 수 있다.

	SELECT 	T.TEAM_NAME 팀명,
		P.PLAYER_NAME 선수명,
		P.BACK_NO 백넘버
	FROM 
		(SELECT 	TEAM_ID, PLAYER_NAME, BACK_NO
		FROM PLAYER
		WHERE POSITION = 'MF'
		) P,
		TEAM T
	WHERE P.TEAM_ID = T.TEAM_ID
	ORDER BY 선수명;

	-> FROM 절에서 TABLE을 불러오는 대신에 SELECT 를 이용하여 임의의 테이블을 생성하여 데이터를 호출하는데 이를 인라인 뷰 라고 한다.

- HAVING 절에서 서브쿼리 사용하기
	HAVING절은 그룹함수와 함께 사용될 때 그룹핑된 결과에 대해 부가적인 조건을 주기 위해서 사용한다.

	SELECT 	P.TEAM_ID 팀코드,
		T.TEAM_NAME 팀명,
		AVG(P.HEIGHT) 평균키
	FROM PLAYER P, TEAM T
	WHERE P.TEAM_ID = T.TEAM_ID
	GROUP BY P.TEAM_ID, T.TEAM_ID
	HAVING AVG(P.HEIGHT) < ( SELECT 	AVG(HEIGHT)
					FROM PLAYER
					WHERE TEAM_ID = 'K02');

	-> 보고싶은 것 팀코드와 팀명과 평균 키. 팀코드와 팀명을 기준으로 평균키를 본다.
	여기서 조건이 평균 키가 K02팀의 평균키가 작은 팀을 대상으로 데이터를 호출한다. 플레이어 	정보는 PLAYER 테이블에, 팀 정보는 TEAM 테이블에 존재한다. 두 테이블을 JOIN으로 묶어 준	다.

-UPDATE 문의 SET 절에서 사용하기 (몰라도 댐)
	UPDATE TEAM A
	SET A.STADIUM_NAME = (	SELECT X.STADIUM_NAME
				FROM STADIUM X
				WHERE X.STADIUM_ID = A.STADIUM_ID);

- INSERT 문의 VALUES절에서 사용하기 (몰라도 댐)
	INSERT
	INTO 	PLAYER
		(PLAYER_ID, PLAYER_NAME, TEAM_ID)
	VALUES 	(SELECT TO_CHAR(MAX(TO_NUMBER(PLAYER_ID))+1) FROM PLAYER),
		'홍길동',
		'K06';

- 뷰(VIEW)
	테이블은 실제로 데이터를 가지고 있는 반면, 뷰는 실제 데이터를 가지고 있지 않다. 뷰는 단지 뷰 정의 만을 가지고 있다.
	질의에서 뷰가 사용되면 뷰 정의를 참조해서 DBMS 내부적으로 질의를 재작성하여 질의를 수행한다.
	뷰는 실제 데이터를 가지고 있지 않지만 테이블이 수행하는 역할을 수행하기 때문에 가상 테이블이라고도 한다.
	* 독립성 : 테이블 구조가 변경되어도 뷰를 사용하는 응용 프로그램은 변경하지 않아도 된다.
	* 편리성 : 복잡한 질의를 뷰로 생성함으로써 관련 질의를 단순하게 작성할 수 있다. 또한 해당 형태의 SQL문을 자주 사용할 대 뷰를 이용하면 편리하게 사용할 수 있다.
	* 보안성 : 직원의 급여정보와 같이 숨기고 싶은 정보라 존재한다면, 뷰를 생성할 대 해당 컬럼을 빼고 생성함으로써 사용자에게 정보를 감출 수 있다.

	CREATE VIEW -> 를 통해 뷰를 만든다.

	CREATE VIEW  V_PLAYER_TEAM AS
	SELECT	P.PLAYER_NAME,		-> 만들 뷰의 내용
		P.POSITION,
		P.BACK_NO,
		P.TEAM_ID,
		T.TEAM_NAME
	FROM PLAYER P, TEAM T
	WHERE P.TEAM_ID = T.TEAM_ID;


	SELECT 	PLAYER_NAME,
		POSITION,
		BACK_NO,
		TEAM_ID,
		TEAM_NAME
	FROM V_PLAYER_TEAM
	WHERE PALYER_NAME LIKE '황%'

	DROP VIEW V_PLAYER_TEAM;

////////////////////////////////////////////////////////////////////////////////////////////////////////////

데이터 분석 개요

	ANSI / ISO SQL 표준은 데이터 분석을 위해서 다음 세가지 함수를 정의하고 있다.

	- AGGREGATE FUNCTION : COUNT, SUM, AVG, MAX, MIN 외 각종 집계함수

	- GROUP FUNCTION : ROLLUP, CUBE, GROUPING SET (소계, 중계, 총합계 등의 여러 레벨로 사용할 때)

	- WINDOW FUNCTION : RANK, DENSE_RANK (분석함수(ANALYTIC FUNCTION, 순위함수 (RANK FUNCTION)

	ROLLUP 함수
		ROLLUP에 지정된 GROUPING COLUMNS의 LIST는 SUBTOTAL을 생성하기 위해 사용되어지며, GROUPING COLUMNS의 수를 N이라고 했을 때 N+1 LEVEL의 SUBTOTAL이 생성된다.
		중요한 것은, ROLLUP의 인수는 계층 구조이므로 인수 순서가 바뀌면 수행 결과도 바뀌게 되므로 인수의 순서도 주의해야 한다.

	-> 일반 GROUP BY와 ROLLUP의 사용 시 차이점.

	일반 GROUP BY
	SELECT 	DNAME, JOB, COUNT(*) "TOTAL EMPL", SUM(SAL) "TOTAL SAL"
	FROM EMP, DEPT
	WHERE DEPT.DEPTNO = EMP.DEPTNO
	GROUP BY DNAME, JOB;

	-> COUNT(*)는 NULL을 포함한 모든 데이터의 숫자를 센다. 이대 GROUP BY를 통해 만들어진 모든 조합들에 대해 각각의 갯수를 센다.

	ORDER BY DNAME, JOB -> DNAME을 우선으로 먼저 ORDERING을 하고 같은 DNAME상에서는 JOB을 기준으로 ORDERING한다.

	*** GROUP BY ROLLUP(DNAME, JOB);
	-> L1 - GROUP BY 수행시 생성되는 표준 집계 (9건)
	L2 - DNAME 별 모든 JOB SUBTOTAL (3건)
	L3 - GRAND TOTAL (마지막 행, 1건)
	추가로 ROLLUP의 경우 계층 산 집계에 대해서는 LEVEL 별 순서 L1->L2->L3를 정렬하지만, 계층 내 GROUP BY 수행시 생성되는 표준 집계에는 별도의 정렬을 지원하지 않는다.
	계층 내 정렬을 위해서는 별도의 ORDER BY 절을 사용해야 한다.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	GROUPING 함수
		ROLLUP, CUBE, GROUPING SETS 등 새로운 그룹 함수를 지원하기 위해 GROUPING 함수가 추가 되었다.
		ROLLUP이나 CUBE에 의한 소계가 계산된 결과에는 GROUPING(EXPR)=1 이 표시되고, 그 이외의 결과에는 GROUPING(EXPR)=0 이 표시된다. -> 계산은 ROLLUP을 사용하면 자동으로 하고, 값을 보기 위해선 GROUPING함수를 이용해 받는다.
		GROUPING 함수와 CASE/DECODE를 이용해, 소계를 나타내는 필드에 원하는 문자열을 지정할 수 있어, 보고서 작성에 유용하다.

	GROUPING 함수의 사용
	SELECT 	DNAME,
		GROUPING(DNAME),
		JOB,
		GROUPING(JOB),
		COUNT(*) "TOTAL EMPL",
		SUM(SAL) "TOTAL SAL"
	FROM EMP, DEPT
	WHERE DEPT.DEPTNO = EMP.DEPTNO
	GROUP BY ROLLUP (DNAME, JOB);

	-> ROLLUP에 의해 소계가 표시된 SUBTOTAL이나 GRAND TOTAL 행에는 GROUPING 값이 1로 표시되고 나머지 행들에 대해서는 0으로 표시된다.

	GROUPING 함수 + CASE 사용
	SELECT CASE GROUPING(DNAME) WHEN 1 THEN 'ALL DEPARTMENT' ELSE DNAME END AS DNAME,
	CASE GROUPING(JOB) WHEN 1 THEN 'ALL JOBS' ELSE JOB END AS JOB,
	COUNT(*) "TOTAL EMPL", SUM(SAL) "TOTAL SAL"
	FROM EMP, DEPT
	WHERE DEPT.DEPTNO = EMP.DEPTNO
	GROUP BY ROLLUP (DNAME, JOB);

	-> 행의 이름을 받을 때, SUBTOTAL과 GRAND TOTAL에 의한 GROUPING값이 0인 경우에는 원래의 이름을 호출, 1인 경우에는 ALL JOBS와 ALL DEPARTMENTS로 호출.

	CASE함수를 DECODE로 정리?
	SELECT 	DECODE (GROUPING(DNAME), 1, 'ALL DEPARTMENTS', DNAME) AS DNAME,
		DECODE (GROUPING(JOB), 1, 'ALL JOBS', JOB) AS JOB,
		COUNT(*) "TOTAL EMPL", SUM(SAL) "TOTAL SAL"
	FROM EMP, DEPT
	WHERE DEPT.DEPTNO = EMP.DEPTNO
	GROUP BY ROLLUP (DNAME, JOB);    -> ROLLUP 순서에 따라 DNAME을 먼저 구분하고 JOB을 구분


	ROLLUP함수 일부 사용
	SELECT 	CASE GROUPING(DNAME) WHEN 1 THEN 'ALL DEPARTMENTS' ELSE DNAME END AS DNAME,
		CASE GROUPING(JOB) WHEN 1 THEN 'ALL JOBS' ELSE JOB END AS JOB,
		COUNT(*) "TOTAL EMPL", SUM(SAL) "TOTAL SAL"
	FROM EMP, DEPT
	WHERE EMP.DEPTNO = DEPT.DEPTNO
	GROUP BY DNAME, ROLLUP(JOB)

	-> JOB에 대해서만 ROLLUP기능 사용. DNAME에 대해서는 SUBTOTAL을 사용하지 않고 JOB에 대해서만 ALL JOB라는 SUBTOTAL을 사용. 따라서 ALL DEPARTMENTS에 대한 행이 호출되지 않는다.

	ROLLUP 함수 결합 컬럼 사용
	SELECT DNAME, JOB, MGR, SUM(SAL) "TOTAL SAL"
	FROM EMP, DEPT
	WHERE DEPT.DEPTNO = EMP.DEPTNO
	GROUP BY ROLLUP (DNAME, (JOB, MGR));

	세 컬럼에 대해서 ROLLUP을 수행. 순서대로 DNAME->JOB->MGR

///////////////////////////////////////////////////////////////////////////////////////////////////////////

	CUBE 함수
		ROLLUP에서는 단지 가능한 SUBTOTAL만을 생성하였지만, CUBE는 결합 가능한 모든 값에 대하여 다차원 집계를 생성한다. CUBE를 사용할 경우에는 내부적으로 GROUPING COLUMNS의 순서를 바꾸어서 또 한번의 QUERY를 추가 수행해야 한다. 뿐만 아니라 GRAND TOTAL은 양족의 QUERY에서 모두 생성이 되므로 한 번의 QUERY에서는 제거되어야만 하므로 ROLLUP에 비해 시스템의 연산 대상이 많다.
		이처럼 GROUPING COLUMNS이 가질 수 있는 모든 경우에 대하여 SUBTOTAL을 생성해야 하는 경우에는 CUBE를 사용하는 것이 바람직하나, ROLLUP에 비해 시스템에 많은 부담을 주므로 사용에 주의해야 한다. CUBE 함수의 경우 표시된 인수들에 대한 계층별 집계를 구할 수 있으며, 이때 표시된 인수들 간에는 계층 구조인 ROLLUP과는 달리 평등한 관계이므로 인수의 순서가 바뀌는 경우 행간에 정렬 순서는 바뀔 수 있어도 데이터 결과는 같다. 그리고 CUBE도 결과에 대한 정렬이 필요한 경우는 ORDER BY 절에 명시적으로 정렬 칼럼이 표시 되어야 한다.

	GROUP BY ROLLUP (DNAME, JOB) -> GRUOP BY CUBE (DNAME, JOB) 으로 조건을 변경

	SELECT 	CASE GROUPING(DNAME) WHEN 1 THEN 'ALL DEPARTMENTS' ELSE DNAME END AS DNAME,
		CASE GROUPING(JOB) WHEN 1 THEN 'ALL JOBS' ELSE JOB END AS JOB,
		COUNT(*) "TOTAL EMPL", SUM(SAL) "TOTAL SAL"
	FROM EMP, DEPT WHERE DEPT.DEPTNO = EMP.DEPTNO
	GROUP BY CUBE (DNAME, JOB);

	-> ROLLUP 과의 차이는 모든 집계에 대해서 SUBTOTAL 및 GRAND TOTAL을 생성한다.
	ROLLUP은 가능한 조건에 대해서만 생성한다. -> DNAME을 상위로 JOB을 카운트 하는 것과 	달리 CUBE는 모든 조건에 대해서 카운트를 한다.
	
	EX) ROLLUP

	SALES			CLERK
	SALES			MANAGER
	SALES			SALESMAN
	SALES			ALL JOBS
	RESEARCH		CLERK
	RESEARCH		ANALYST
	RESEARCH		MANAGER
	RESEARCH		ALL JOBS
	ACCOUNTING		CLERK
	ACCOUNTING		MANAGER
	ACCOUNTING		PRESIDENT
	ACCOUNTING		ALL JOBS
	ALL DEPARTMENTS	ALL JOBS

	EX) CUBE
	
	ALL DEPARTMENTS 	ALL JOBS
	ALL DEPARTMENTS 	CLERK
	ALL DEPARTMENTS 	ANALYST
	ALL DEPARTMENTS 	MANAGER
	ALL DEPARTMENTS 	SALESMAN
	ALL DEPARTMENTS 	PRESIDENT
	SALES			ALL JOBS
	SALES			CLERK
	SALES			MANAGER
	SALES			SALESMAN
	RESEARCH		ALL JOBS
	RESEARCH		CLERK
	RESEARCH		ANALYST
	RESEARCH		MANAGER
	ACCOUNTING		ALL JOBS
	ACCOUNTING		CLERK
	ACCOUNTING		MANAGER
	ACCOUNTING		PRESIDENT
	
	-> GROUPING하고자 하는 칼럼이 많으면 많을수록 경우의 수는 그 컬럼수의 곱 만큼을 구하기 때문에 CUBE를 사용하면 많은 데이터를 사용하게 된다.

	이는 UNION ALL을 통해 묶은 다음과 유사하다.
	SELECT DNAME, JOB, COUNT(*) "TOTAL EMPL", SUM(SAL) "TOTAL SAL"
	FROM EMP, DEPT
	WHERE DEPT.DEPTNO = EMP.DEPTNO
	GROUP BY DNAME, JOB	-> GROUPING하지 않은 데이터들만 우선적으로 호출
	
	UNION ALL

	SELECT DNAME, 'ALL JOBS', COUNT(*) "TOTAL EMPL", SUM(SAL) "TOTAL SAL"
	FROM EMP, DEPT
	WHERE DEPT.DEPTNO = EMP.DEPTNO
	GROUP BY DNAME		-> DNAME에 대해서만 GROUPING하고 JOBDMS 'ALL JOBS'로

	UNION ALL
		
	SELECT 'ALL DEPARTMENTS' , JOB, COUNT(*) "TOTAL EMPL", SUM(SAL) "TOTAL SAL"
	FROM EMP, DEPT
	WHERE DEPT.DEPTNO = EMP.DEPTNO
	GROUP BY JOB

	UNION ALL

	SELECT 'ALL DEPARTMENTS', 'ALL JOBS', COUNT(*) "TOTAL EMPL", SUM(SAL) "TOTAL SAL"
	FROM EMP, DEPT
	WHERE DEPT.DEPTNO = EMP.DEPTNO;

/////////////////////////////////////////////////////////////////////////////////////////////////////////

	GROUPING SETS 함수 ***********
		GROUP MY SQL 문장을 여러번 반복하지 않아도 원하는 결과를 쉽게 얻을 수 있게 되었다. 
	GROUPING SETS에 표시된 인수들에 대한 개별 집계를 구할 수 있으며, 이때 표시된 인수들 간에는 계층 구조인 ROLLUP과는 달리 평등한 관계이므로 인수의 순서가 바뀌어도 결과는 같다.
	GROUPING SETS함수도 결과에 대한 정렬이 필요한 경우는 ORDER BY 절에 명시적으로 정렬 칼럼이 표시가 되어야 한다.

	SELECT 	DECODE (GROUPING(DNAME), 1, 'ALL DEPARTMENTS', DNAME) AS DNAME,
		DECODE (GROUPING(JOB), 1, 'ALL JOBS', JOB) AS JOB,
		COUNT(*) "TOTAL EMPL", SUM(SAL) "TOTAL SAL"
	FROM EMP, DEPT 
	WHERE DEPT.DEPTNO = EMP.DEPTNO
	GROUP BY GROUPING SETS (JOB, DNAME);

	-> ALL DEPARTMENTS와 직업들에 대해서 COUNT, DNAME과 ALL JOS들에 대해서 COUNT한다.
	반면에 GROUP BY ROLLUP ( DNAME, JOB); 을 수행하면
	DNAME을 우선으로 JOB들을 분류하여 COUNT한다.

	SELECT DNAME, JOB, MGR, SUM(SAL) "TOTAL SAL"
	FROM EMP, DEPT
	WHERE DEPT.DEPTNO = EMP.DEPTNO
	GROUP BY GROUPING SETS ((DNAME, JOB, MGR), (DNAME, JOB), (JOB, MGR));

	-> GROUPING SETS에 오는 인수들은 상위 하위의 개념이 없이 동등하다.
	

////////////////////////////////////////////////////////////////////////////////////////////////////////////////

윈도우 함수 (WINDOW FUNCTION)

행과 행 간의 관계를 쉽게 정의하기 위해 만든 함수이다.
분석함수(ANALYTIC FUNCTION나 순위함수(RANK FUNCTION)으로도 알려져 있는 윈도우 함수는 데이터웨어하우스에서 발전한 기능이다.
WINDOW 함수는 다른 함수와는 달리 중첩(NEST)해서 사용하지는 못하지만, 서브쿼리에서는 사용할 수 있다.

순위 관련(RANK) - RANK, DENSE_RANK, ROW_NUMBER
집계 관련(AGGREGATE) - SUM, MAX, MIN, AVG, COUNT
순서 관련 함수 - 오라클만 지원
그룹 내 비율 관련 함수 - PERCENT_RANK
선형분석을 포함한 통계 분석 함수 - CORR, COVAR_POP, COVAR_SAMP, STDDEV, STDDEV_POP, STDDEV_SAMP, VARIANCE, VAR_POP, VAR_SAMP, REGR_(LINEAR REGRESSION), REGR_SLOPE, REGR_INTERCEPT, REGR_COUNT, REGR_R2, REGR_AVGX, REGR_AVGY, REGR_SXX, REGR_SYY, REGR_SXY

WINDOW FUNCTIO SYNTAX
	OVER 문구가 키워드로 필수 포함된다.
	
	SELECT WINDOW_FUNCTION (ARGUMENTS) OVER ( [PARTITION BY 칼럼] [ORDER BY 절] [WINDOWING 절] )
	FROM 테이블 명;

	BETWEEN 사용 타입
	ROWS | RANGE BETWEEN UNBOUNDED PRECEDING | CURRENT ROW | VALUE_EXPR PRECDDING/FOLLOWING AND UNBOUNDED FOLLOWING | CURRENT ROW | VALUE_EXPR PRECEDING/FOLLOWING

	BETWEEN 미사용 타입
	ROWS | RANGE UNBOUNDED PRECEDING | CURRENT ROW | VALUE_EXPR PRECEDING

	WINDOW_FUNCTION : ARGUMENTS (인수) 함수에 따라 0-N개의 인수가 지정 될 수 있다.
	PARTITION BY 절 : 전체 집합을 기준에 의해 소그룹으로 나눌 수 있다.
	ORDER BY 절 : 어떤 항목에 대해 순위를 지정할 지 ORDER BY 절을 기술한다.
	WINDOING 절 : WINDOWING 절은 함수의 대상이 되는 행 기준의 범위를 강력하게 지정할 수 있다. ROWS는 물리적인 결과 행의 수를, RANGE는 논리적인 값에 의한 범위를 나타내는데, 둘 중의 하나를 선택해서 사용할 수 있다. WINDOWING은 SQL SERVER에서는 지원하지 않는다.

그룹 내 순위 함수

RANK 함수 - RANK 함수는 ORDER BY를 포함한 QUERY 문에서 특정 항목(컬럼) 에 대한 순위를 구하는 	함수이다.
	이때 특정 범위(PARTITION) 내에서 순위를 구할 수도 있고 전체 데이터에 대한 순위를 구할 수		도 있다. 또한 동일한 값에 대해서는 동일한 순위를 부여하게 된다.

	SELECT 	JOB, ENAME, SAL,
		RANK() OVER (ORDER BY SAL DESC) ALL_RANK, 
		RANK() OVER (PARTITION BY JOB ORDER BY SAL DESC) JOB_RANK
	FROM EMP;

	ALL RANK라는 항목을 만들어 SAL을 기준으로 정렬. (내림차순 - 숫자가 작아지게.)
	JOB RANK라는 항목을 만들어 직업별로 파티션을 나누고 직업별 SAL을 기준으로 정렬.

	SELECT 	JOB, ENAME, SAL,
		RANK() OVER (PARTITION BY JOB ORDER BY SAL DESC) JOB_RANK
	FROM EMP;
	
	JOB RANK라는 항목을 만들 직업별로 파티션을 나누고 직업별 SAL을 내림차순으로 정렬

DENSE_RANK 함수
	
	SELECT 	JOB, ENAME, SAL,
		RANK() OVER (ORDER BY SAL DESC) RANK,
		DENSE_RANK () OVER (ORDER BY SAL DESC) DENSE_RANK
	FROM EMP; 

	-> 중복 상관없이 순위를 매김.
	예를 들어 RANK는 1,2,2,4 와같이 매기는 반면 DENSE_RANK는 1,2,2,3으로 매김.

ROW_NUMBER 함수
	ROW_NUMBER 함수는 RANK나 DENSE_RANK 함수가 동일한 값에 대해서는 동일한 순위를 부		여하는데 반해, 동일한 값이라도 고유한 순위를 부여한다.

-	SELECT 	JOB, ENAME, SAL,
		RANK() OVER (ORDER BY SAL DESC) RANK,
		ROW_NUMBER () OVER (ORDER BY SAL DESC) ROW_NUMBER
	FROM EMP;

	-> RANK상으로 동일한 순위여도 다른 ROW_NUMBER를 부여한다.

SUM 함수
	SUM 함수를 이용하여 파티션별 윈도우의 합을 구할 수 있다.

	SELECT 	MGR, ENAME, SAL,
		SUM(SAL) OVER (PARTITION BY MGR) MGR_SUM
	FROM EMP;
	
	-> MGR별로 파티션을 나누고 MGR별로 SAL의 합을 구한다.

	SELECT 	MGR, ENAME, SAL,
		SUM(SAL) OVER (PARTITION BY MGR ORDER BY SAL
				 RANGE UNBOUNDED PRECEDING) AS MGR_SUM
	FROM EMP;

	-> RANGE : 논리적인 상대번지로 행 집합을 지정한다.
	UNBOUNDED PRECEDING : PARTITION의 마지막 로우에서 윈도우가 시작한다.
	???????????????????? 나중에 다시

MAX 함수
	SELECT 	MGR, ENAME, SAL,
		MAX(SAL) OVER (PARTITION BY MGR) AS MGR_MAX
	FROM EMP;

	-> 매니저 별로 최고 SAL인 사람의 이름을 호출

	SELECT 	MGR, ENAME, SAL
	FROM 
		(SELECT 	MGR, ENAME, SAL,
			MAX(SAL) OVER (PARTITION BY MGR) AS IV_MAX_SAL
		FROM EMP)
	WHERE SAL = IV_MAX_SAL;

	-> MGR, ENAME, SAL, IV_MAX_SAL 이 컬럼인 테이블을 생성. IV_MAX_SAL 은 각 MGR에 대한 	파티션 내에서 최고 SAL를 호출. 이 테이블에서 MGR, NAME, SAL = IV_MAX_SAL를 만족하는 	SAL를 호출. 즉, 각 매니저에 대해서 MAX SAL을 받는 직원에 대해서 MGR, 이름, SAL을 호출

MIN 함수
	SELECT 	MGR, ENAME, HIREDATE, SAL,
		MIN(SAL) OVER(PARTITION BY MGR ORDER BY HIREDATE) AS MGR_MIN
	FROM EMP;

	-> MGR 별로 파티션을 나누어 MGR별로 MIN SAL를 구하고, HIREDATE를 기준으로 오름차순 	정렬한다. (오름차순이 DAFAULT 작은값 -> 큰값)

AVG 함수
	EMP 테이블에서 같은 매니저를 두고 있는 사원들의 평균 SAL을 구하는데, 조건은 같은 매니저 	내이서 자기 바로 앞의 사번과 바로 뒤의 사번인 직원만을 대상으로 한다.
	
	SELECT 	MGR, ENAME, HIREDATE, SAL
		ROUND( AVG(SAL) OVER (PARTITION BY MGR ORDER BY HIREDATE ROWS 		BETWEEN 1 PRECEDING AND 1 FOLLOWING)) AS MGR_AVG
	FROM EMP;

	-> ROWS : 물리적인 ROW 단위로 행 집합을 지정한다. <->논리적 범위 (RANGE)
	BETWEEN - AND : 윈도우 절의 시작과 끝 위치를 지정한다. ( 범위를 지정해준다)
	????? UNBOUNDED -> 처음부터 끝가지
	1 PRECEDING :  해당 열의 1행 앞 열에서 부터 시작
	1 FOLLOWING : 해당 열의 1행 뒤 열까지.
	
	-> ROUND 반올림. 매니저 별로 파티션을 생성. 평균 SAL을 구하는데, 해당 매니저 내에서 앞	의 1행과 뒤의 1행에 한해서 평균을 구한다.

COUNT 함수
	SELECT 	ENAME, SAL,
		COUNT(*) OVER ( ORDER BY SAL RANGE BETWEEN 50 PRECEDING AND 150 				FOLLOWING) AS SIM_CNT
	FROM EMP;

	-> RANGE는 논리적인 값. 해당 행의 값이 -50 +150인 범위에 들어오는 값들을 COUNT한다.

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

그룹 내 행 순서 함수

FIRST_VALUE 함수

	파티션별 윈도우에서 가장 먼저 나온 값을 구한다.
	MIN 함수를 활용하여 같은 결과를 얻을 수 있다.

LAST_VALUE 함수

	파티션별 윈도우에서 가장 나중에 나온 값을 구한다.
	MAX 함수를 활용하여 같은 결과를 얻을 수 있다.

LAG 함수
	
	파티션별로 윈도우에서 이전 몇 번째 행의 값을 가져올 수 있다.
	
	3개의 인자를 사용할 수 있다.
	두번째 인자는 몇번째 앞의 행을 가져올지 정하는 인수
	세번째 인자는 앞의 행의 값을 가져올때 NULL인경우 대체할 값

LEAD 함수

	LEAD 함수를 이용해 파티션별 윈도우에서 이후 명 번째 행의 값을 가져올 수 있다.

	LAG 함수와 마찬가지

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

그룹 내 비율 함수

RATIO_TO_REPORT 함수

	RATIO_TO_REPORT 함수를 이용해 파티션 내 전체 SUM(칼럼)값에 대한 행별 칼럼 값의 백분	율을 소수점으로 구할 수 있다.
	0과1 사이의 값을 가진다.

PERCENT_RANK 함수

	파티션별 윈도우에서 제일 먼저 나오는 것을 0으로, 제일 늦게 나오는 것을 1로 하여, 값이 아	닌 행의 순서별로 백분율을 구한다.

CUME_DIST 함수

	파티션별 윈도우의 전체건수에서 현재 행보다 작거나 같은 건수에 대한 누적 백분율을 구한	다.

NTILE 함수

	파티션별 전체 건수를 ARGUMENT 값으로 N등분한 결과를 구할 수 있다.

	NTILE(VALUE) -> VALUE값을 N등분한다. -> 정수값만 받은건가?

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DCL (DATA CONTROL LANGUAGE)

유저를 생성하고 권한을 제어할 수 있는 데이터 언어

	ORACLE -> 아이디와 비밀번호 방식으로 인스턴스에 접속을 하고, 그에 해당하는 스키마에 	오브젝트 생성 등의 권할을 부여받게 된다.

	SQL SERVER -> WIDOW 인증 방식으로 WINDOWS에 로그인한 정보를 가지고 SQL SERVER	에 접속하는 방식이다.
	혼합모드 방식으로 기본적으로 WINDOWS 인증으로도 SQL SERVER에 접속 가능.

	->SQL SERVER는 유저를 생성하기 전 먼저 로그인을 생성해야 한다.
	로그인을 생성할 수 있는 권한을 가진 로그인은 기본적으로 SA이다.
	
ROLE을 이용한 권한 부여
	
	데이터베이스에서 유저들과 권한들 사이에서 중개 역할을 하는 ROLE을 제공한다.
	데이터베이스 관리자는 ROLE을 생성하고, ROLE에 각종 권한들을 부여한 후 ROLE을 다른 	ROLE이나 유저에게 부여할 수 있다.
	또한 ROLE에 포함되어 있는 권한들이 필요한 유저에게는 해당 ROLE만을 부여함으로써 빠르	고 정확하게 필요한 권한을 부여할 수 있게 된다.
	ROLE에는 시스템 권한과 오브젝트 권한을 모두 부여할 수 있으며, ROLE은 유저에게 직접 부	여될 수도 있고, 다른 ROLE에 포함하여 유저에게 부여될 수도 있다.
	
	SQL SERVER에서는 ORACLE과 같이 ROLE을 자주 사용하지 않는다. 대신 위에서 언급한 서버 	수준 역할 및 데이터베이스 수준 역할을 이용하여 로그인 및 사용자 권한을 제어한다.
	인스턴스 수준의 작업이 필요한 경우 서버 수준 역할을 부여하고 그보다 작은 개념인 데이터	베이스 수준의 권한이 필요한 경우 데이터베이스 수준의 역할을 부여하면 된다.
	즉, 인스턴스 수준을 요구하는 로그인에는 서버 수준 역할을, 데이터베이스 수준을 요구하는 	사용자에게는 데이터베이스 수준 역할을 부여한다.

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
그룹 내 비율 함수

PERCENT_RANK 함수
	PERCENT_RANK 함수를 이용해 파티션별 윈도우에서 제일 먼저 나오는 것으로 0으로, 제일 	늦게 나오는 것을 1로 하여, 값이 아닌 행의 순서별로 백분율을 구한다.
	결과 값은 >=0 & <=1의 범위를 가진다.

	SELECT 	DEPTNO, ENAME, SAL,
		PERCENT_RANK() OVER (PARTITION BY DEPTNO ORDER BY SAL DESC) AS P_R
	FROM EMP;

	-> 먼저 각 부서별로 파티션을 나눈 뒤 SAL을 기준으로 내림차순으로 정렬. 그리고 난 뒤 각 		부서별로의 최대값을 0, 최소값을 1로 하여 백분위값을 계산해 준다.

//////////////////////////////////////////////////////////////////////////////////////////////////////////

절차형 SQL 개요

	일반적으로 개발 언어처럼 SQL에도 절차 지향적인 프로그램을 벤더별로 제공

	ORACLE - PL(PROCEDURAL LANGUAGE)/SQL(ORACLE)
	DB2 - SQL/PL
	SQL SERVER - T-SQL

PL/SQL
	ORACLE의 PL/SQL은 BLOCK 구조로 되어있고 BLOCK 내에는 DML 문장과 QUERY문장, 그리	고 절차형 언어(IF, LOOP) 등을 사용할 수 있다.
	특징은 저장 모듈을 이용해서 PL/SQL을 데이터베이스에 저장하여 독립적으로 실행되거나 다	른 프로그램으로부터 실행될 수 있는 완전한 실행 프로그램이다.
	ORACLE의 저장 모듈에는 PROCEDURE, USER DEFINED FUNCTION, TRIGGER가 있다.

	특징
	- PL/SQL은 BLOCK 구조로 되어있어 각 기능별로 모듈화가 가능하다.
	- 변수, 상수 등을 선언하여 SQL 문장 간 값을 교환한다.
	- IF, LOOP 등의 절차형 언어를 사용하여 절차적인 프로그램이 가능하도록 한다.
	- DBMS 정의 에러나 사용자 정의 에러를 정의하여 사용할 수 있다.
	- PL/SQL은 ORACLE에 내장되어 있으므로 ORACLE과 PL/SQL을 지원하는 어떤 서버로도 프	로그램을 옮길 수 있다.
	- PL/SQL은 응용 프로그램의 성능을 향상시킨다.
	- PL/SQL은 여러 SQL 문장을 BLOCK으로 묶고 한 번에 BLOCK 전부를 서버로 보내기 때문에 	통신량을 줄일 수 있다.

	- PL/SQL BLOCK 프로그램을 입력받으면 SQL 문장과 프로그램 문장을 구분하여 처리한다.
	- 프로그램 문장은 PL/SQL 엔진이 처리하고 SQL 문장은 ORACLE 서버의 SQL STATEMENT 	EXECUTOR가 실행하도록 작업을 분리하여 처리한다.

	PL/SQL 블록 구조
		
		(필수) DECLARE - 선언부(변수, 상수) 	BEGIN~END에서 사용할 변수나 인수에 							대한 정의 및 데이터 타입 선언

		(필수) BEGIN - 실행부		개발자가 처리하고자 하는 SQL문과
						필요한 로직이 정의되는 실행부
		
		(선택) EXCEPTION - 예외 처리부	BEGIN~END에서 실행되는 SQL문에
						발생된 에러를 처리하는 에러 처리부

		(필수) END


	PL/SQL 기본 문법(SYNTAX)

	CREATE [OR REPLACE] PROCEDURE [PROCEDURE_NAME]
	( ARGUMENT1 [IN|OUT|INOUT] DATA_TYPE1,
	ARGUMENT2 [IN|OUT|INOUT] DATA_TYPE2, ...)
	
	IS [AS] ...

	BEGIN ...

	EXCEPTION ....

	END;


	DROP PROCEDURE [PROCEDURE_NAME];


T-SQL

	근본적으로 SQL SERVER를 제어하기 위한 언어로 MS가에서 ANSI/ISO 표준의 SQL에 약간의 기능을 더 추가해 보완적으로 만든 것이다.
	다양한 저장 모듈을 개발할 수 있다.

	 - 변수 선언 기능 @@이라는 전역변수(시스템 함수)와 @이라는 지역변수가 있다.
	 - 지역변수는 사용자가 자신의 연결 시간 동안만 사용하기 위해 만들어지는 변수이며 전역변수는 이미 SQL 서버에 내장된 값이다.
	 - 데이터 유형(DATA TYPE)을 제공한다. INT, FLOAT, VARCHAR 들의 자료형을 의미한다.
	 - 연산자(OPERATOR) 산술연산자와 비교연산자, 논리연산자 사용이 가능하다.
	 - 흐름 제어 기능 IF-ELSE와 WHILE, CASE-THEN 사용이 가능하다.
	 - 주석 가능한줄 주석 : --

	- T-SQL 구조

		(필수) DECLARE - 선언부(변수, 상수) 	BEGIN~END에서 사용할 변수나 인수에 							대한 정의 및 데이터 타입 선언

		(필수) BEGIN - 실행부		개발자가 처리하고자 하는 SQL문과
						필요한 로직이 정의되는 실행부
		
		(선택) ERROR 처리 - 예외 처리부	BEGIN~END에서 실행되는 SQL문에
						발생된 에러를 처리하는 에러 처리부

		(필수) END

	T-SQL 기본 문법(SYNTAX)

	CREATE PROCEDURE [SCHEMA_NAME.]PROCEDURE_NAME
	@PARAMETER1 DATA_TYPE1 [VARYING결과 집합|DEFAULT|OUT|READONLY],
	@PARAMETER2 DATA_TYPE2 [MODE], ...
	
	WITH [OPTION RECOMPILE|||] ...
	AS

	BEGIN ...

	ERROR 처리 ....

	END;

	DROP PROCEDURE [SCHEMA_NAME.]PROCEDURE_NAME;


USER DEFINED FUNCTION의 생성과 활용

	USER DEFINED FUNCTION은 PROCEDURE처럼 절차형 SQL을 로직과 함께 데이터베이스	내에 저장해 놓은 명령문의 집합을 의미한다.
	SUM, SUBSTR, NVL 등의 함수는 벤더에서 미리 만들어둔 내장 함수이고, 사용자가 별도	의 함수를 만들 수도 있다.
	FUNCTION이 PROCEDURE와 다른 점은 RETURN을 사용해서 하나의 값을 반드시 되돌려 	줘야 한다는 것이다. 특정 작업을 수행하고 반드시 수행 결과를 리턴.

TRIGGER의 생성과 활용

	TRIGGER란 특정한 테이블에 INSER, UPDATE, DELETE와 같은 DML문이 수행되었을 때, 	데이터베이스에서 자동으로 동작하도록 작성된 프로그램이다.
	사용자가 직접 호출하여 사용하는 것이 아니고 데이터베이스에서 자동적으로 수행하게 	된다. TRIGGER는 테이블과 뷰, 데이터베이스 작업을 대상으로 정의할 수 있다.

	TRIGGER선언
		CREATE TRIGGER 트리거명 : TRIGGER 선언문
		ON 테이블명 : 테이블에 TRIGGER 설정
		AFTER INSERT : 입력이 된 후 TRIGGER 발생

	 	DECLARE 후 변수 선언

		INSERTED - 신규로 입력된 레코드의 정보를 가지고 있는 구조체
		DELETED - 수정, 삭제되기 전의 레코드를 가지고 있는 구조체

	구분		DELETED			INSERTED
	INSERT		NULL			입력된 레코드 값
	UPDATE		UPDATE되기 전의 레코드 값	UPDATE된 후의 레코드 값
	DELETE		레코드가 삭제되기 전 값	NULL

	
	* PROCEDURE와 TRIGGER의 차이점

	프로시저는 BEGIN ~ END 절 내에 COMMIT, ROLLBACK과 같은 트랜잭션 종료 명령어를 사용할 수 있지만 데이터베이스 TRIGGER는 BEGIN ~ END 절 내에 사용할 수 없다.

	PROCEDURE			TRIGGER

	CREATE PROCEDURE 문법 사용	CREATE TRIGGER 문법 사용
	EXECUTE 명령어로 실행		생성 후 자동으로 실행
	COMMIT, ROLLBACK 실행 가능	COMMIT, ROLLBACK 실행 안됨


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
DCL( DATA CONTROL LANGUAGE)
	유저들을 생성하고 권한을 제어 할 수 있는 DCL

	유저와 권한 : 첫 번째, WINDOWS 인증 방식으로 WINDOWS에 로그인한 정보를 가지고 SQL SERVER에 접속하는 방식이다. (트러스트 된 연결)
	두 번째, 혼합모드 방식으로 기본적으로 WINDOWS 인증으로도 접속 가능

CREATE 	LOGIN PJS WITH PASSWORD='KOREA7',
	DEFAULT_DATABASE=ADVENTUREWORKS
USE ADVENTUREWORKS;
GO
CREATE 	USER PJS FOR LOGIN PJS
	WITH DEFAULT_SCHEMA = DBO;

GRANT CREATE TABLE TO PJS;
GRANT CONTROL ON SCHEMA;

객체권한 		테이블	VIEWS	 SEQUENC	PROCEDURE
ALTER		O		O
DELETE		O	O	O
EXECUTE						O
INDEX		O
INSERT		O	O
REFERENCES	O
SELECT		O	O	O
UPDATE		O	O

ROLE을 이용한 권한 부여
	데이터베이스에서 유저들과 권한들 사이에 중개 역할을 하는 ROLE을 제공한다.
	데이터베이스 관리자는 ROLE을 생성하고, ROLE에 각종 권한들을 부여한 후 ROLE을 다른 ROLE이나 유저에게 부여할 수 있다.
	또한 ROLE에 포함되어 있는 권한들이 필요한 유저에게는 해당 ROLE만을 부여함으로써 빠르고 정확하게 필요한 권한을 부여할 수 있게 된다.
	ROLE에는 시스템 권한과 오브젝트 권한을 모두 부여할 수 있으며, ROLE은 유저에게 직접 주여될 수도 있고, 다른 ROLE에 포함하여 유저에게 부여될 수도 있다.
