
데이터베이스

	데이터베이스는 일상적인 정보들을 모아 놓은 것 자체를 의미한다.

	효율적인 데이터의 관리 뿐만 아니라 예기치 못한 사건으로 인한 데이터의 손상을 피하고, 필	요시 필요한 데이터를 복구하기 위한 강력한 기능의 소프트웨어를 필요로 하게 되었고 이러	한 기본적인 요구사항을 만족시켜주는 시스템을 DBMS(DATABASE MANAGEMENT SYSTEM)	라고 한다.

	데이터베이스의 발전
		1960 - 플로우차트 중심의 개발. 파일 구조를 통해 데이터를 저장 및 관리
		1970 - 계층형 데이터베이스, 망형 데이터베이스가 상용화
		1980 - 관계형 데이터베이스가 상용화. ORACLE, SYBASE, DB2
		1990 - 많은 제품들이 보다 향상된 기능으로 정보시스템의 확실한 핵심 솔루션으로 		자리 잡게 됨. 인터넷 환셩의 급속한 발전과 객체 지향 정보를 지원하기 위해 객체 		관계형 데이터베이스로 발전하였다.

	관계형 데이터베이스(RALATIONAL DATABASE)
		1970년 영국 수학자에 의해 처음 소개. SQL 개발 단계를 거쳐서, ORACLE을 선발로 		상용화된 제품이 개발됨.
		기존의 파일시스템과 계층형, 망형 데이터베이스를 대부분 대체하면서 주력 데이터		베이스가 되었다.

	현재 기업에서 사용하고 있는 대부분의 데이터베이스는 기존 관계형 데이터베이스에 객체 기	능을 추가한 객체 관계형 데이터베이스를 사용하고 있지만, 현실적으로 기업의 핵심 데이터	는 대부분 관계형 데이터베이스 구조로 저장되고, 관계형 데이터베이스를 유일하게 조작할 	수 있는 SQL 문장에 의해 관리되고 있으므로 관계형 데이터베이스와 SQL의 중요성은 아무리 	강조해도 지나치지 않다.

	파일 시스템
		하나의 파일 시스템을 많은 사용자가 동시에 검색할 수는 있지만 동시에 입력, 수정, 		삭제할 수 없기 때문에 정보의 관리가 어려우므로, 하나의 파일을 여러 사용자나 어		플리케이션에서 동시에 사용하기 위해서 원래의 데이터 파일을 여러 개 복사하여 		사용하게 된다.
		여러 개의 데이터 파일이 존재하는 경우에 동일한 데이터가 여러 곳에 저장되는 문		제가 발생하고, 하나의 원본 파일에 대한 변경 작업이 발생했을 때 모든 복사본 파		일에 대한 변경 작업을 한꺼번에 병행 처리하지 않으면 서로 다른 정보 파일이 존재		하기 때문에 데이터의 불일치성이 발생한다.
		파일 시스템은 분산된 데이터 간의 정합성을 유지하는데 과다한 노력이 필요하게 		되고 데이터의 정합성을 보장하기 힘들게 된다.
		단일 사용자나 단일 어플리케이션이 파일시스템을 사용하는 경우 데이터베이스보		다 처리 성능이 뛰어나므로 특정 업무에서는 아직도 파일시스템을 유용하게 사용하		고 있다.

	관계형 데이터베이스
		정규화를 통한 합리적인 테이블 모델링을 통해 이상(ANOMALY) 현상을 제거하고 		데이터 중복을 피할 수 있으며, 동시성 관리, 병행 제어를 통해 많은 사용자들이 동		시에 데이터를 공유 및 조작할 수 있는 기능을 제공하고 있다.
		메타 데이터를 총괄 관리할 수 있기 때문에 데이터의 성격, 속성 또는 표현 방법들		을 체계화할 수 있고, 데이터 표준화를 통한 데이터 품질을 확보할 수 있는 장점을 		가지고 있다.
		DSMS는 인증된 사용자만이 참조할 수 있도록 보안 기능을 제공하고 있다.
		테이블 생성 시에 다양한 제약조건을 이용하여 사용자가 실수로 조건에 위배되는 		데이터를 입력한다든지, 관계를 연결하는 중요한 데이터를 삭제하는 것을 방지하여 		데이터 무결성(INTERGRITY)을 보장할 수 있다.
		시스템의 갑작스런 장애로부터 사용자가 입력, 수정, 삭제하던 데이터가 제대로 반		영될 수 있도록 보장해주는 기능과, 시스템 다운, 재해 등의 상황에서도 데이터를 회		복/복구할 수 있는 기능을 제공한다.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////


SQL (STRUCTURED QUERY LANGUAGE)

	SQL
		관계형 데이터베이스에서 데이터 정의, 데이터 조작, 데이터 제어를 하기 위해 사용		하는 언어
		1986년부터 ANSI/ISO를 통해 표준화되고 정의된 SQL 기능은 벤더별 DBMS 개발의 		목표가 됨.
		대부분의 관계형 데이터베이스에서 ANSI/ISO 표준을 최대한 따르고 있기 때문에, 		SQL에 대한 지식은 다른 데이터베이스를 사용하더라도 상당 부분 기존 지식을 재		활용할 수 있음.
		SQL 문장은 일반적인 개발 언어처럼 독립된 하나의 개발 언어이다.
		일반적인 프로그래밍 언어와는 달리 SQL은 관계형 데이터베이스에 대한 전담언어 		용도로 사용되며 세미콜론(;)으로 분리되어있는 SQL 문장 단위로 독립되어 있음.
		관계형 데이터베이스는 수학의 집합 논리에 입각한 것이므로, SQL도 데이터를 집합		으로써 취급함.
		결과적으로 SQL문장을 배우는 것이 곧 관계형 데이터베이스를 배우는 기본 단계이		다.

	SQL 문장
		단순히 조회를 하는 SELECT 문장
		데이터에 변경을 가하는 UPDATE, DELETE, INSERT
		테이블을 생성하고 수정하고 변경하고 삭제하는 테이블 관련 SQL 문장이 있고, 추		가로 데이터에 대한 권한을 제어하는 SQL 문장도 있다.

	데이터 조작어(DML; DATA MANIPULATION LANGUAGE)
		SELECT - 데이터베이스에 들어있는 데이터를 조회하거나 검색하기 위한 명령어.
		INSERT, UPDATE, DELETE - 데이터베이스의 테이블에 들어있는 데이터에 변형을 가		하는 종유의 명령어들을 말한다. 예를 들어 데이터를 테이블에 새로운 행을 집어넣		거나, 원하지 않는 데이터를 삭제하거나 수정하는 명령어들을 DML이라고 부른다.
	
	데이터 정의어(DDL; DATA DEFINATION LANGUAGE)
		CREATE, ALTER, DROP, RENAME - 테이블과 같은 데이터 구조를 정의하는데 사용되		는 명령어들로 그러한 구조를 생성하거나 변경하거나 삭제하거나 이름을 바꾸는 데		이터 구조와 관련된 명령어들을 DDL이라고 부른다.

	데이터 제어어(DCL; DATA CONTROL LANGUAGE)
		GRANT, REVOKE - 데이터베이스에 접근하고 객체들을 사용하도록 권한을 주고 회		수하는 명령어를 DCL이라고 부른다.

	트랜잭션 제어어(TCL; TRANSCATION CONTROL LANGUAGE)
		COMMIT, ROLLBACK - 논리적인 작업의 단위를 묶어서 DML에 의해 조작된 결과를 		작업단위(트랜잭션) 별로 제어하는 명령어를 말한다.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////


TABLE

	K-LEAGUE에 등록되어 있는 팀들의 정보와 선수들에 관련된 데이터에 관심을 두고, 선수정보	를 데이터베이스화 한다.

	다음은 K-리그 구단 홈페이지를 방문하겨 팀 및 선수들의 정보를 찾아서 선수들의 이름과 소	속 구단, 포지션, 생년월일, 키, 몸무게, 등번호를 노트에 적어본 것이다.
	정리되지 않은 내용은 본인이 아니라면 알아보기 힘들고 다른 사용자에게 도움이 되지 않으	므로 표를 이용하여 키는 키대로, 몸무게는 몸무게대로 데이터의 순서를 정해서 비교하는 것	이 바람직하다.

	-> 테이블은 데이터를 저장하는 객체(OBJECT)로서 관계형 데이터베이스의 기본 단위이다.
	관계형 데이터베이스에서는 모든 데이터를 칼럼과 행의 2차원 구조로 나타낸다.
	테이블은 어느 특정한 주제와 목적으로 만들어지는 일종의 집합이다.

	테이블은 반드시 하나 이상의 칼럼을 가져야 한다.
	테이블에는 등록된 자료들이 있으며, 이 자료들은 삭제하지 않는 한 지속적으로 유지된다.
	자료를 입력하지 않는다면 테이블은 본래 만들어졌을 때부터 가지고 있던 속성을 그대로 유		지하면서 존재하게 된다.

	세로 방향을 칼럼(COLUMN), 가로방향을 행(ROW)이라 하고, 칼럼과 행이 겹치는 하나의 공간	을 필드(FIELD)라고 한다.
	선수정보 테이블을 예로 들면 선수명과 포지션 등의 칼럼이 있고, 각 선수에 대한 테이터를 	행으로 구성하여 저장한다.

	(선수 테이블)
	선수번호	이름	팀 코드	포지션	등번호	키
	1	김남일	K03	DF	33	177
	2	박지성	K07	MF	7	178
	3	이영표	K02	MF	22	176
	
	(구단 테이블)
	팀 코드	팀 명	연고지
	K03	스틸러스	포항
	K07	드래곤즈	전남
	K02	블루윙즈	수원

	-> 위의 테이블들을 보면 선수와 관련된 데이터를 선수 테이블과 구단 테이블이라는 복수의 	테이블로 분할하여 저장하고 있다.
	그리고 분할된 테이블은 그 칼럼의 값에 의해 연결된다.
	이렇게 테이블을 분할하여 데이터의 불필요한 중복을 줄이는 것을 정규화(NORMALIZATION)	라고 한다.
	데이터의 정합성 확보와 데이터 입력/수정/삭제시 발생할 수 있는 이상현상(ANONALY)을 방	지하기 위해 정규화는 관계형 데이터베이스 모델링에서 매우 중요한 프로세스이다.

	기본키(PRIMARY KEY)
		각 행을 한가지 의미로 특정할 수 있는 한 개 이상의 칼럼 (선수 테이블의 '선수번호		'와 구단 테이블의 '구단코드')
	외부키(FOREIGNKEY)
		다른 테이블의 기본 키로 사용되면서 테이블과의 관계를 연결하는 역할을 하는 칼		럼 (선수 테이블의 '구단코드')

	* 정규화 - 테이블을 분할하여 데이터의 정합성(무모순성)을 확보하고, 불필요한 중복을 줄이	는 프로세스
	기본키 - 테이블에 존재하는 각 행을 한가지 의미로 특정할 수 있는 한 개 이상의 칼럼
	외부키 - 다른 테이블의 기본키로 사용되고 있는 관계를 연결하는 칼럼

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ERD ( ENTITY RELATIONAL DIAGRAM)

	테이블 간 서로의 상관 관계를 그림으로 도식화한 것을 E-R 다이어그램이라고 하며, 간략히 	ERD라고 함.
	구성 요소는 엔터티, 관계, 속성 3가지이며 현실 세계의 데이터는 이 3가지 구성 요소로 모두 	표현이 가능함

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DDL (DATA DEFINATION LANGUAGE)

데이터 유형 (DATA TYPE)

	데이터베이스의 테이블에서 특정 자료를 입력할 때, 그 자료를 받아들일 공간을 자료의 유형		별로 나누는 기준.
	특정 칼럼을 정의할 때 선언한 데이터 유형은 그 칼럼이 받아들일 수 있는 자료의 유형을 규		정
	선언한 유형이 아닌 다른 종류의 데이터가 들어오려고 하면 데이터베이스는 에러를 발생시킴
	데이터 유형과 더불어 지정한 크기(SIZE)도 중요한 기능을 제공, 지정한 데이터의 크기를 넘어		선 자료가 입력되는 상황에서는 에러를 발생

	데이터 유형(숫자타입)
		ANSI/ISO 기준에서는 NUMERIC TYPE의 하위 개념으로 NUMERIC, DECIMAL, DEC, 			SMALLINT, INTEGER, INT, BIGINT, FLOAT, REAL, DOUBLE PRECISION
		SQL SERVER와 SYBASE는 ANSI/ISO 기준의 하위 개념에 맞추어서 작은 정수형, 정			수형, 큰 정수형, 실수형 등 여러 숫자 타입을 제공하고 있으며, 추가로 MONEY, 			SAMLLMONET 등의 숫자 타입도 가지고 있음.
		ORACLE은 숫자형 타입에 대해서 NUMBER 한가지 숫자 타입의 데이터 유형만 지원

		CHARACTER(S)  
			고정 길이 문자열.(ORACLE, SQL SERVER 모두 CHAR로 표현)
			S는 기본길이 1바이트, 최대길이 ORACLE 2,000바이트, SQL SERVER 					8,000바이트 
			S만큼 최대길이를 갖고 고정길이를 가지고 있으므로 할당된 변수 값의 길				이가 S보다 작을 경우에는 그 차이 길이만큼 공간으로 채워진다

			CHAR에서는 문자열을 비교할 때 공백을 채워서 비교
			CHAR의 공백 채우기 비교에서는 우선 짧은 쪽 컬럼의 끝에 공백을 추가				하여 2개의 데이터가 같은 길이가 되도록 하고 앞에서부터 한 문자씩 비				교

			고정된 깅이의 문자열을 가지는 경우(주민등록번호, 코드성컬럼)

			'AA' = 'AA '
		
		VARCHAR(S)  
			CHARACTER VARYING의 약자로 가변 길이 문자열 정보. (ORACLE은 					VARCHAR2로, SQL SERVER은 VARCHAR로 표현)
			S는 최소길이 1바이트, 최대길이 ORACLE 4,000바이트, SQL SERVER 					8,000바이트
			S만큼의 최대 길이를 갖기만 가변 길이로 조정이 되기 때문에 할당된 변				수값의 바이트만 적용된다.
		
			VARCHAR 유형은 가변 길이이므로 필요한 영역은 실제 데이터 크기 뿐
			길이가 다양한 칼럼과, 정의된 길이와 실제 데이터 길이에 차이가 있는 칼				럼에 적합
			CHAR 유형보다 작은 영역에 저장할 수 있음
			VARCHAR 유영 문자열 비교에서 처음부터 한 문자씩 비교하고 공백도 하				나의 문자로 취급하므로 끝의 공백이 다르면 다른 문자로 판단

			고정된 길이의 문자열을 자기기 않는 경우(팀명, 선수이름, 아이디)

			'AA' !='AA '

		NUMERIC	  
			정수, 실수 등 숫자 정보(ORACLE은 NUMBER로, SQL SERVER는 10가지 				이상의 숫자 타입을 가지고 있음)
			ORACLE은 처음에 전체 자리 수를 지정하고, 그 다음 소수 부분의 자리 수				를 지정한다.
			예를 들어, 정수 부분이 6자리이고 소수점 부분이 2자리인 경우에는 					NUMBER(8,2)와 같다.

		DATETIME 
			날짜와 시각 정보(ORACLE은 DATE로 표현, SQL SERVER는 DATETIME으로 			표현)
			ORACLE은 1초 단위, SQL SERVER는 3.33MS 단위관리

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
CREATE TABLE

	테이블은 일정한 형식에 의해서 생성
	테이블 생성을 위해서는 해당 테이블에 입력될 데이터를 정의하고, 정의한 데이터를 어떠한 		데이터 유형으로 선언할 것인지를 결정	

	CREATE TABLE 테이블명(
		칼럼명1 DATATYPE [DEFAULT 형식],
		칼럼명2 DATATYPE [DEFAULT 형식],
		칼럼명3 DATATYPE [DEFAULT 형식]
	);

	-> 테이블명은 객체를 의미할 수 있는 적절한 이름을 사용한다. 가능한 단수형을 권고한다.
	테이블 명은 다른 테이블의 이름과 중복되지 않아야 한다.
	한 테이블 내에서는 칼럼명이 중복되게 지정할 수 없다.
	테이블 이름을 지정하고 각 컬럼들은 괄호'()'로 묶어 지정한다.
	각 컬럼들은 콤마','로 구분되고, 테이블 생성문의 끝은 항상 세미콜론 ';'으로 끝난다.
	칼럼에 대해서는 다른 테이블까지 고려하여 데이터베이스 내에서는 일관성 있게 사용하는 것		이 좋다.
	칼럼 뒤에 데이터 유형은 꼭 지정되어야 한다.
	테이블명과 칼럼명은 반드시 문자로 시작해야 하고, 벤더별로 길이에 대한 한계가 있다.
	EX) 10_PLAYER, T-PLAYER 와 같은 테이블명은 허용되지 않는다.
	한 테이블 안에서 칼럼명은 달라야 하지만, 다른 테이블의 칼럼 이름과는 같을 수 있다. 

	테이블 생성시 대/소문자 구분은 하지 않는다. 기본적으로 테이블이나 칼럼명은 대문자로 만		들어진다.
	DATATIME 데이터 유형에는 별도로 크기를 지정하지 않는다.
	문자 데이터 유형은 반드시 가질 수 있는 최대 길이를 표시해야 한다.
	칼럼과 컬럼의 구분은 콤마로 하되, 마지막 칼럼은 콤마를 찍지 않는다.
	칼럼에 대한 제약조건이 있으면 CONSTRAINT를 이용하여 추가할 수 있다.

	제약조건은 데이터 유형 뒤에 NOT NULL을 정의한 사례와 같은 칼럼 LEVEL 벙의 방식과, 		PRIMARY KEY, FOREIGN KEY 사례처럼 테이블 생성 마지막에 모든 제약조건을 기술하는 테이		블 LEVEL 방식이 있다.


제약조건 (CONSTRAINT)

	데이터의 무결성을 유지하기 위한 데이터베이스의 보편적인 방법으로 테이블의 특정 칼럼을 		설정하는 제약
	테이블을 생성할 때 제약조건을 반드시 기술할 필요는 없지만, 이후에 ALTER을 이용해서 추		가, 수정하는 경우 데이터가 이미 입력된 경우라면 처리 과정이 쉽지 않으므로 초기 테이블 		생성부터 적합한 제약 조건에 대한 충분한 검토가 있어야 한다.

	PRIMARY KEY(기본키) - 테이블에 저장된 행 데이터를 고유하게 식별하기 위한 기본키를 정의			한다. 하나의 테이블에 하나의 기본키 제약만 정의할 수 있다.
		기본키 제약을 정의하면 DBMS는 자동으로 UNIQUE 인덱스를 생성하며, 기본키를 			구성하는 칼럼에는 NULL을 입력할 수 없다.
		결국 '기본키 제약 = 고유키 제약 + NOT NULL 제약' 이 된다.

	UNIQUE KEY(고유키) - 테이블에 저장된 행 데이터를 고유하게 식별하기 위한 고유키를 정의			한다. 단 NULL은 고유키 제약의 대상이 아니므로, NULL 값을 가진 행이 여러 개가 			있더라도 고유키 제약 위반이 되지 않는다.

	NOT NULL - NULL값의 입력을 금지한다. 디폴트 상태에서는 모든 칼럼에서 NULL을 허가하			고 있지만, 이 제약을 지정함으로써 해당 칼럼은 입력 필수가 된다. NOT NULL을 			CHECK의 일부분으로 이해할 수도 있다.

	CHECK - 입력할 수 있는 값의 범위 등을 제한한다. CHECK 제약으로는 TRUE OR FALSE로 평			가할수 있는 논리식을 지정한다.

	FOREIGH KEY(외래키) - 관계형 데이터베이스에서 테이블 간의 관계를 정의하기 위해 기본키			를 다른 테이블의 외래키로 복사하는 경우 외래키가 생성된다.
		외래키 지정시 참조 무결성 제약 옵션을 선택할 수 있다.

	* NULL의 의미
		NULL(ASCII CODE 00번)은 공백(BLANK, ASCII CODE 32번)이나 숫자0(ZERO, ASCII 			CODE 48)과는 전혀 다른 값이며, 조건에 맞는 데이터가 없을 때의 공집합과도 다르				다.
		NULL은 아직 정의되지 않은 미지의 값이거나 현재 데이터를 입력하지 못하는 경우			를 의미한다.

	* DAFAULT의 의미
		데이터 입력시에 칼럼의 값이 지정되어 있지 않을 경우 기본값을 사전에 설정할 수 			있다.
		데이터 입력시 명시된 값을 지정하지 않은 경우에 NULL 값이 입력되고, DEFAULT 			값을 정의했다면 해당 칼럼에 NULL값이 입력되지 않고 사전에 정의된 기본값이 자			동으로 입력된다.

	CREATE PLAYER(
		PLAYER_ID CHAR(7) NOT NULL,
		TEAM_ID CHAR(3) NOT NULL,
		REGION_NAME VARCHAR(8) NOT NULL,
		OWNER VARCHAR(10) NOT NULL
		
		CONSTRAINT PLAYER_PK PRIMARY KEY (PLAYER_ID)
		CONSTRAINT PLAYER_FK FOREIGN KEY (TEAM_ID) REFERENCES TEAM(TEAM_ID)
	);

	-> CONSTRAINT 키이름 PRIMARY/FOREIGN KEY (컬럼명) 
	FOREIGN KEY인 경우 REFERENCE 테이블명(컬럼명)

생성된 테이블 구조의 확인

	ORACLE의 경우 DESCRIBE 테이블명/ DESC 테이블명 으로 해당 테이블에 대한 정보를 확인
	SQL SERVER의 경우 EXEC SP_HELP 'DBO.테이블명' 으로 해당 테이블에 대한 정보를 확인

SELECT 문장을 통핸 테이블 생성 사례

	CATS ( CREATE TABLE ~ AS SELECT ~) -> 기존의 테이블을 복제하는 형식
		DML 문장 중에 SELECT 문장을 활용해서 테이블을 생성하는 방법
		칼럼별로 데이터 유형을 다시 재정의 하지 않아도 되는 장점
		CATS 기법 사용시 주의할 점은 기존 테이블의 제약조건 중에 NOT NULL만 새로운 			복제 테이블에 적용이 되고, 기본키, 고유키, 외래키, CHECK 등의 다른 제약 조건은 			없어짐
		SQL SERVER에서는 SELECT ~ INTO ~ 를 활용하여 위와 같은 결과를 얻을 수 있음
		칼럼 속성에 IDENTITY를 사용했다면 IDENTITY 속성까지 같이 적용됨


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ALTER TABLE

ADD COLUMN - 	기존 테이블에 필요한 칼럼을 추가하는 명령
	
	ALTER TABLE 테이블명 ADD 추가할칼럼명 데이터유형;
	-> 새롭게 추가된 칼럼은 테이블의 마지막 칼럼이 되며 칼럼의 위치를 지정할 수는 없다.

DROP COLUMN - 	테이블에서 필요 없는 칼럼을 삭제할 수 있으며, 데이터가 있거나 없거나 모두 삭제 		가능
		한 번에 하나의 칼럼만 삭제 가능하며, 칼럼 삭제 후 최소 하나 이상의 칼럼이 테이		블에 존재해야 함.
		한 번 삭제된 칼럼은 복구가 불가능함.

	ALTER TABLE 테이블명
	DROP COLUMN 삭제할 칼럼명;

MODIFY COLUMN-	칼럼의 데이터 유형, 디폴트(DEFAULT)값, NOT NULL 제약조건에 대한 변경을 포함		할 수 있음.
		
	(ORACLE)
	ALTER TABLE 테이블명
	MODIFY (칼럼명1 데이터유형 [DEFAULT 식] [NOT NULL],
		칼럼명2 데이터유형...)

	[SQL SERVER]
	ALTER TABLE 테이블명
	ALTER (칼럼명1 데이터유형 [DEFAULT 식] [NOT NULL],
		칼럼명2 데이터유형...)

	-> 해당 칼럼의 크기를 늘릴 수는 있지만 줄이지는 못한다. 이는 기존 데이터가 훼손될 수 있		기 때문이다.
	해당 칼럼이 NULL값만 가지고 있거나 테이블에 아무 행도 없으면 칼럼의 폭을 줄일 수 있다.
	해당 칼럼이 NULL 값만을 가지고 있으면 데이터 유형을 변경할 수 있다.
	해당 칼럼의 DEFAULT 값을 바꾸면 변경 작업 이후에 발생하는 삽입에만 영향을 미치게 된다.
	해당 칼럼에 NULL 값이 없을 경우에만 NOT NULL 제약조건을 추가할 수 있다.

	EX) TEAM 테이블의 ORIG_YYYY 칼럼의 데이터 유형을 CHAR(4)에서 VARCHAR(8)로 변경하고		, 향후 입력되는 데이터의 DAFAULT 값으로 '20020129'로 적용, 모든 행의 ORIG_YYYY 칼럼에 	NULL 값이 없으므로 제약조건을 NOT NULL로 변경한다.

	(ORACLE)
	ALTER TABLE TEAM_TEMP
	MODIFY (ORIG_YYYY VARCHAR2(8) DAFAULT '20020129' NOT NULL);

	(SQL SERVER)
	ALTER TABLE TEAM_TEMP
	ALTER COLUMN ORIG_YYYY VARCHAR(8) NOT NULL;
	
	ALTER TABLE TEAM_TEMP
	ADD CONSTRAINT DF_ORIG_YYYY DAFAULT '20020129' FOR ORIG_YYYY;
	
	->  ??? SQL SERVER에서 왜 이렇게 나누어서 변경하는지 모르겠음

RENAME COLUMN - 테이블을 생성하면서 만들어졌던 칼럼멸을 어떤 이유로 불가피하게 변경해야 하는 경우에 유용하게 쓰일 수 있는 문구이다.
	
	ALTER TABLE 테이블명
	RENAME COLUMN 변경해야하는 칼럼명 TO 새로운 칼럼명;

	-> RENAME COLUMN으로 칼럼명이 변경되면, 해당 칼럼과 관계된 제약조건에 대해서도 자		동으로 변경되는 장점이 있지만, ADD/DROP 기능과 같이 ANSI/ISO에 명시되어 있는 기능이 		아니고 ORACLE 등 일부 DBMS에서만 지원하는 기능이다.
	
	-> SQL SERVER에서는 SP_RENAME 저장 프로시저를 이용하여 칼럼 이름을 변경할 수 있다.

	SP_RENAME 변경해야하는 칼럼명, 새로운 칼럼명, 'COLUMN';

DROP CONSTRAINT - 테이블 생성 시 부여했던 제약조건을 삭제하는 명령어 형태는 다음과 같다.

	ALTER TABLE 테이블명
	DROP CONSTRAINT 제약조건명;

ADD CONSTRAINT - 테이블 생성 시 제약조건을 적용하지 않았다면, 생성 이후에 필요에 의해서 제약조건을 추가할 수 있다.
	
	ALTER TABLE 테이블명
	ADD CONSTRAINT 제약조건명 제약조건 (칼럼명);

	
* 외래 키에 의해 참조되는 고유/기본 키가 존재하는 테이블은 DROP TABLE에 의해 삭제되지 않는다.
또한 외래키에 의해 참조되는 테이블의 데이터 또한 DELETE FROM에 의해서 삭제되지 않는다.

-> 참조 제약조건을 추가하면 참조 무결성 옵션에 따라서 삭제가 불가능하게 제약을 할 수 있다.
즉, 외부키를 설정함으로써 실수에 의해 테이블 삭제나 필요한 데이터의 의도하지 않은 삭제와 같은 불상사를 방지하는 효과를 볼 수 있다.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

RENAME TABLE - RENAME 명령어를 사용하면 테이블의 이름을 변경할 수 있다.

	(ORACLE)
	RENAME 변경전 테이블명 TO 변경후 테이블명;

	(SQL SERVER)
	SP-RENAME 변경전 테이블명, 변경후 테이블명;

	-> 주의 : 엔터티 이름 부분을 변경하면 스크립트 및 저장 프로시저를 손상시킬 수 있다.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DROP TABLE - 불필요한 테이블을 삭제하는 명령

	DROP TABLE 테이블명 [CASCADE CONSTRAINT]

	테이블의 모든 데이터 및 구조를 삭제
	CASCADE CONSTRAINT 옵션은 해당 테이블에 참조되는 제약조건에 대해서도 삭제
	SQL SERVER에서는 CASCADE 옵션이 존재하지 않으며 테이블을 삭제하기 전에 참조하는 		FOREIGN KEY 제약조건 또는 참조하는 테이블을 먼저 삭제해야 함

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

TRUNCATE TABLE - 테이블에 들어있던 모든 행들이 제거되고 저장 공간을 재사용 가능하도록 해제
		테이블 구조를 완전히 삭제하기 위해서는 DROP TABLE을 실행

	TRUNCATE TABLE 테이블명;

	-> DROP TABLE과는 다르게 테이블 구조는 유지한 채로 데이터만 삭제한다. 따라서 DROP 	TABLE이후에는 테이블 조회가 안되지만, TRUNCATE는 조회가 가능하다.





