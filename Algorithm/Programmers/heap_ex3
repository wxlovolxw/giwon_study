하드디스크는 한 번에 하나의 작업만 수행할 수 있습니다. 디스크 컨트롤러를 구현하는 방법은 여러 가지가 있습니다.
가장 일반적인 방법은 요청이 들어온 순서대로 처리하는 것입니다.

예를들어

- 0ms 시점에 3ms가 소요되는 A작업 요청
- 1ms 시점에 9ms가 소요되는 B작업 요청
- 2ms 시점에 6ms가 소요되는 C작업 요청

와 같은 요청이 들어왔습니다. 이를 그림으로 표현하면 아래와 같습니다.


한 번에 하나의 요청만을 수행할 수 있기 때문에 각각의 작업을 요청받은 순서대로 처리하면 다음과 같이 처리 됩니다.

- A: 3ms 시점에 작업 완료 (요청에서 종료까지 : 3ms)
- B: 1ms부터 대기하다가, 3ms 시점에 작업을 시작해서 12ms 시점에 작업 완료(요청에서 종료까지 : 11ms)
- C: 2ms부터 대기하다가, 12ms 시점에 작업을 시작해서 18ms 시점에 작업 완료(요청에서 종료까지 : 16ms)
이 때 각 작업의 요청부터 종료까지 걸린 시간의 평균은 10ms(= (3 + 11 + 16) / 3)가 됩니다.


하지만 A → C → B 순서대로 처리하면


- A: 3ms 시점에 작업 완료(요청에서 종료까지 : 3ms)
- C: 2ms부터 대기하다가, 3ms 시점에 작업을 시작해서 9ms 시점에 작업 완료(요청에서 종료까지 : 7ms)
- B: 1ms부터 대기하다가, 9ms 시점에 작업을 시작해서 18ms 시점에 작업 완료(요청에서 종료까지 : 17ms)
이렇게 A → C → B의 순서로 처리하면 각 작업의 요청부터 종료까지 걸린 시간의 평균은 9ms(= (3 + 7 + 17) / 3)가 됩니다.


각 작업에 대해 [작업이 요청되는 시점, 작업의 소요시간]을 담은 2차원 배열 jobs가 매개변수로 주어질 때,
작업의 요청부터 종료까지 걸린 시간의 평균을 가장 줄이는 방법으로 처리하면 평균이 얼마가 되는지 return 하도록 solution 함수를 작성해주세요.
(단, 소수점 이하의 수는 버립니다)


제한 사항

jobs의 길이는 1 이상 500 이하입니다.
jobs의 각 행은 하나의 작업에 대한 [작업이 요청되는 시점, 작업의 소요시간] 입니다.
각 작업에 대해 작업이 요청되는 시간은 0 이상 1,000 이하입니다.
각 작업에 대해 작업의 소요시간은 1 이상 1,000 이하입니다.
하드디스크가 작업을 수행하고 있지 않을 때에는 먼저 요청이 들어온 작업부터 처리합니다.


입출력 예
jobs	                    return
[[0, 3], [1, 9], [2, 6]]	9

입출력 예 설명
문제에 주어진 예와 같습니다.

0ms 시점에 3ms 걸리는 작업 요청이 들어옵니다.
1ms 시점에 9ms 걸리는 작업 요청이 들어옵니다.
2ms 시점에 6ms 걸리는 작업 요청이 들어옵니다.

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

모든 작업요청들에 대해서 가장 빨리 끝나도록 작업시간을 조정해야 한다.
-> 요청에서 종료까지의 평균시간이 최소가 되도록하는게 중요하다.

작업하고 있지 않을 때, 먼저 들어온 작업에 대해서 먼저 시행한다. 라는 조건이 예외적인 상황을 발생시킬 것 같다.

배열 한 뒤, 요청시간부터 작업종료 시간까지의 시간을 측정한다.

1) 배열하는 방식에 대한 고려.

2) 배열을 통해 시간을 측정했을 때, 그 시간이 최소가 되는지를 확인

3) 리턴값이 평균시간값이므로 어떻게 반환할지를 생각

///////////////////////////////////////////////////////////////////////////////////////////////////////

[[0, 3], [1, 9], [2, 6]]

현재 count가 0이므로 0번 인덱스 값이 가장 작은 [0,3]이 시행된다.

count는 3으로 바뀌고, 만약 이 카운트가 다음 시행보다 작게 된다면, 바로 다음 입력이 실행된다.

아니라면 시간 비교를 통해 다음 순서를 정해야 한다. 앞에서부터 최소로 채워 나가는 것이 맞는것 같다.

요청 시간이 순서대로 배열되어있기 때문에, 앞에 몇개만 비교해서 최소를 넣고, 그다음 최소를 넣는 식으로.

그렇다면 요청시간부터 작업종료시간까지의 시간 차이를 리스트의 요소로 집어 넣어야 한다.

////////////////////////////////////////////////////////////////////////////////////////////////

first = heapq.heappop(h) -> 와 같은 형태로 pop을 바로 변수에 저장하는 것도 가능하다.

////////////////////////////////////////////////////////////////////////////////////////////////

0 - 인덱스의 값을 해당 시간 차이로 변경하여, 이 값을 heap를 통해 count를 다시 하는 식으로 알고리즘을 짜보자

[[0, 3], [1, 9], [2, 6]]

처음 count = 0 -> heap을 통해 첫번째 [0,3]을 가져오고, 이때 count는 3으로 변경.

그렇다면 [1,9]와 [2,6]은 어떻게 변하는지. -> 길이가 짧을수록 평균합이 작아지는지?

순서대로 한다면, [1,9]는 3초에서 시작하여 12초에서 종료. 요청시간부터 완료시간은 11초
                [2,6]은 12초에 시작 18초에 종료. 요청시간으로부터 완료시간은 16초 -> 이 둘의 평균은 13.5

문제에서 요구한 순은 [2,6]이 3초에 시작. 3초부터 9초까지 -> 요청으로부터 완료시간이 7초 ->
                    [1,9]는 9초에 시작 18초에 완료 -> 요청으로부터는 17초 -> 이 둘의 평균은 12초로 아래와 같은 순의 알고리즘을 짜야한다.


우리에게 필요한 변수는 무엇인지 생각해보자.

    [[x1,y1],[x2,y2],[x3,y3]]

    count가 y1이 된다. -> 이때 입력시간은 x2 < x3일 것이고,

    [x2,y2]에 대해서 요청부터 완료까지 시간은 x2부터 y1+y2 ,  [x3,y3]에 대한 요청부터 완료까지 시간은 x3부터 y1+y3가 된다.

    여기서 비교를 한번 시행해야 한다. -> y1+y2-x2의 값과 y1+y3-x3값이 작을수록 우선순위가 앞당겨지므로 이 값이 작아야 우선 시행.

    이 y2-x2와 y3-x3에 대해서 전자가 2번째 시행인 경우, 후자가 2번쨰 시행인 경우로 나눠보자.

    -> [x2,y2]가 우선인 경우, count = y1 + y2가 되며, [x3,y3]의 요청부터 완료 시간은 y1+y2+y3-x3가 된다.
    이 경우 평균 시간은 (y1 + (y1+y2-x2) + (y1+y2+y3-x3)) / 3

    [x3,y3]가 우선인 경우 평균시간은 (y1 + (y1+y3-x3) + (y1+y2+y3-x2)) / 3

    -> 둘의 차이를 비교해 보자면, 전자는 2y2+y3이며 후자는 2y3+y2가 된다. 단순히 y의 값을 비교하면 되는 것 같다.
    주어진 범위 내에서 1-th index의 값을 비교한 뒤, 작은 순서대로 순위를 매기면 된다.

    *** 주어진 범위 내의 값들에 대해서 연산을 하는게 제일 중요한 부분인 듯 하다.

    -> 루프가 끝날때 요청부터 완료까지의 시간을 append하는 식으로 하여 마지막에 이 리스트의 평균값을 반환하는 식으로 해야 할 것 같다.

    -> 전체 리스트와 비교를 통해 heap을 사용할 힙은 다른데 어떻게 해야할지. 두번째 요소의 순서를 바꿔주면 상관없나?

    -> 결국에 heap을 사용할 요소는 1-th index이기 때문에.

///////////////////////////////////////////////////////////////////////////////////////////////////////

[[0, 3], [1, 9], [2, 6]] -> [[3,0],[9,1],[6,2]]

heap을 통해 뽑으면, [3,0]이 뽑힐 것이고, 뒤의 숫자가 입력시간을 의미하므로
count와 small[1]을 비교했을때 small[1] <= count이면 이 시행이 진행된다.

만약 small[1] <= count라면 ? -> 카운트 내의 진행들에 대해서 비교시키는 방법은 없을까??? 리스트를 나눴다가 다시 더해주는 방식?
-> 해보자.

리스트를 count보다 큰 리스트와 작은 리스트로 나눴을 때, 알고리즘을 어떻게 짜야 할까?

count보다 요청시간이 작은 작업이 들어온다면, 그 중에 작업시간이 가장 짧은 작업이 먼저 시행된다.
만약 count보다 짧은 요청시간의 작업이 없다면, 그 다음으로 요청시간이 가장 가까운 작업을 먼저 시행하면 된다.

-> 이때 count가 제대로 안들어간다.

만약 기존 count가 4였고, 다음 시행이 시작이 5가 된다면,

//////////////////////////////////////////////////////////////////////////////////////////////////////

    대략적인 틀을 짜보자.

    result_list = [] # 요청부터 완료시간을 넣기 위한 리스트

    count = 0 # count를 0으로 초기화

    while True : # 반복문

        if jobs == [] : break   # 더이상 연산할 리스트가 남아있지 않다면 break를 통해 빠져나온다.

        jobs_small = [x for x in jobs if x[0] <= count] #count보다 작은 요청시간에 대해서 진행해야 하므로, jobs를 두개의 리스트로 나눠주었다.
        jobs_big = [x for x in jobs if x[0] > count]

        if jobs_small != [] :
            jobs_small = list(map(lambda x : [x[1],x[0]], jobs_small))
            next_job = hq.heappop(jobs_small)   # small중에
            count += next_job[0]
            result_list.append(count+next_job[0]-next_job[1])
            jobs_small = list(map(lambda x : [x[1],x[0]], jobs_small))

        else :  # jobs_small이 비었다면 요청시간이 가장 작은 작업을 시행해야 하므로,
            next_job = hq.heappop(jobs_big)
            count += next_job[1]
            result_list.append(count+next_job[1]-next_job[0])

        jobs = jobs_small + jobs_big

    if result_list == [] : return 0
    else : return avg(result_list) #를 통해 평균값을 반환해 준다.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

하나의 테스트 케이스만 성공하고 다른 케이스들은 성공하지 못했다.

런타임 또한 오래 걸려 전혀 효율적인 알고리즘이 아닌 것 같다.

시간만을 받을 수 있는 간단한 방법에 대해서 고려해보자.

[[0, 3], [1, 9], [2, 6]]

-> count = 0 에 대한 요청시간부터 완료까지의 시간을 모두 계산

    [0,3] -> 3 + 0 - 0 = 3
    [1,9] -> 9 + 0 - 1 = 8
    [2,6] -> 6 + 0 - 2 = 4

    [0,3] 이 시행되며 count = 3, result_list = [3]이 추가된다

-> count = 3 에 대한 요청시간부터 완료까지의 시간을 모두 계산

    [1,9] -> 9 + 3 - 1 = 11
    [2,6] -> 6 + 3 - 2 = 7

    [2,6] 이 시행되며 count = 3 + 6, result_list = [3,7]가 추가된다.

-> count = 9 에 대한 시행은 count = 3 + 6 + 9가 되고, result_list = [3,7,17]이 되고,

return sum(result_list) / len(result_list) 로 9가 반환되어야 한다.

//////////////////////////////////////////////////////////////////////////////////////////////////////////

다른 테스트 케이스를 생각해보자.

[[1,2],[3,4],[5,6],[7,8]]
count 1 부터 시작 -> count = 3 -> count = 7 -> 13

result_list = [2, 4, 8, 14] -> 28 / 4 = 7

해결.

[[0, 3], [1, 9], [2, 6], [3,2], [4,2], [5,1]]

-> 반올림을 해줘야 하는데 안한 것이 문제였다. round를 통해 반올림을 해주니 75/100이 되었다.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

import heapq as hq

def solution(jobs) :

    result_list = [] # 요청부터 완료시간을 넣기 위한 리스트

    count = 0 # count를 0으로 초기화

    while True : # 반복문

        if jobs == [] : break   # 더이상 연산할 리스트가 남아있지 않다면 break를 통해 빠져나온다.

        jobs_small = [x for x in jobs if x[0] <= count] #count보다 작은 요청시간에 대해서 진행해야 하므로, jobs를 두개의 리스트로 나눠주었다.
        jobs_big = [x for x in jobs if x[0] > count]

        if jobs_small != [] :
            jobs_small = list(map(lambda x : [x[1],x[0]], jobs_small))
            hq.heapify(jobs_small)
            next_job = hq.heappop(jobs_small)   # small중에
            result_list.append(count+next_job[0]-next_job[1])
            count += next_job[0]
            jobs_small = list(map(lambda x : [x[1],x[0]], jobs_small))

        else :  # jobs_small이 비었다면 요청시간이 가장 작은 작업을 시행해야 하므로,
            hq.heapify(jobs_big)
            next_job = hq.heappop(jobs_big)
            result_list.append(next_job[1])
            count = next_job[0]+next_job[1]

        jobs = jobs_small + jobs_big

    if result_list == [] : return 0
    else : return round(sum(result_list)/len(result_list))

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

-> 버림을 해야하는데 계속 반올림을 해서 잘못된 결과가 나왔다.

math.trunc()를 사용하니 정답이 나왔다.

-> 아직 힙의 사용법이 익숙하지 않으니 많이 연습해두자.

