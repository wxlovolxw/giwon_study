문제 설명
XX게임에는 피로도 시스템(0 이상의 정수로 표현합니다)이 있으며, 일정 피로도를 사용해서 던전을 탐험할 수 있습니다.
이때, 각 던전마다 탐험을 시작하기 위해 필요한 "최소 필요 피로도"와 던전 탐험을 마쳤을 때 소모되는 "소모 피로도"가 있습니다.
"최소 필요 피로도"는 해당 던전을 탐험하기 위해 가지고 있어야 하는 최소한의 피로도를 나타내며,
"소모 피로도"는 던전을 탐험한 후 소모되는 피로도를 나타냅니다. 예를 들어 "최소 필요 피로도"가 80,
"소모 피로도"가 20인 던전을 탐험하기 위해서는 유저의 현재 남은 피로도는 80 이상 이어야 하며,
던전을 탐험한 후에는 피로도 20이 소모됩니다.

이 게임에는 하루에 한 번씩 탐험할 수 있는 던전이 여러개 있는데, 한 유저가 오늘 이 던전들을 최대한 많이 탐험하려 합니다.
유저의 현재 피로도 k와 각 던전별 "최소 필요 피로도", "소모 피로도"가 담긴 2차원 배열 dungeons 가 매개변수로 주어질 때,
유저가 탐험할수 있는 최대 던전 수를 return 하도록 solution 함수를 완성해주세요.

제한사항
k는 1 이상 5,000 이하인 자연수입니다.
dungeons의 세로(행) 길이(즉, 던전의 개수)는 1 이상 8 이하입니다.
dungeons의 가로(열) 길이는 2 입니다.
dungeons의 각 행은 각 던전의 ["최소 필요 피로도", "소모 피로도"] 입니다.
"최소 필요 피로도"는 항상 "소모 피로도"보다 크거나 같습니다.
"최소 필요 피로도"와 "소모 피로도"는 1 이상 1,000 이하인 자연수입니다.
서로 다른 던전의 ["최소 필요 피로도", "소모 피로도"]가 서로 같을 수 있습니다.

입출력 예
k	dungeons	                result
80	[[80,20],[50,40],[30,10]]	3

입출력 예 설명
현재 피로도는 80입니다.

만약, 첫 번째 → 두 번째 → 세 번째 던전 순서로 탐험한다면

현재 피로도는 80이며, 첫 번째 던전을 돌기위해 필요한 "최소 필요 피로도" 또한 80이므로, 첫 번째 던전을 탐험할 수 있습니다.
첫 번째 던전의 "소모 피로도"는 20이므로, 던전을 탐험한 후 남은 피로도는 60입니다.
남은 피로도는 60이며, 두 번째 던전을 돌기위해 필요한 "최소 필요 피로도"는 50이므로, 두 번째 던전을 탐험할 수 있습니다.
두 번째 던전의 "소모 피로도"는 40이므로, 던전을 탐험한 후 남은 피로도는 20입니다.
남은 피로도는 20이며, 세 번째 던전을 돌기위해 필요한 "최소 필요 피로도"는 30입니다. 따라서 세 번째 던전은 탐험할 수 없습니다.

만약, 첫 번째 → 세 번째 → 두 번째 던전 순서로 탐험한다면

현재 피로도는 80이며, 첫 번째 던전을 돌기위해 필요한 "최소 필요 피로도" 또한 80이므로, 첫 번째 던전을 탐험할 수 있습니다.
첫 번째 던전의 "소모 피로도"는 20이므로, 던전을 탐험한 후 남은 피로도는 60입니다.
남은 피로도는 60이며, 세 번째 던전을 돌기위해 필요한 "최소 필요 피로도"는 30이므로, 세 번째 던전을 탐험할 수 있습니다.
세 번째 던전의 "소모 피로도"는 10이므로, 던전을 탐험한 후 남은 피로도는 50입니다.
남은 피로도는 50이며, 두 번째 던전을 돌기위해 필요한 "최소 필요 피로도"는 50이므로, 두 번째 던전을 탐험할 수 있습니다.
두 번째 던전의 "소모 피로도"는 40이므로, 던전을 탐험한 후 남은 피로도는 10입니다.
따라서 이 경우 세 던전을 모두 탐험할 수 있으며, 유저가 탐험할 수 있는 최대 던전 수는 3입니다.

///////////////////////////////////////////////////////////////////////////////////////////////////////////

80	[[80,20],[50,40],[30,10]]

k값과 dungeon에 대한 정보를 입력받는다.

k값은 초기의 피로도 값을 의미한다.

dungeon에 대한 첫번째 값은 던전에 입장하기 위한 최소의 피로도를 의미한다.
즉 이 값 이상의 피로도 이상을 가지고 있어야 던전에 입장할 수 있다.

dungeon에 대한 두번째 값은 던전에서 소비하는 피도로를 의미한다.
던전에서 나온 뒤에 k값에서 이값을 뺀 만큼이 남게 된다.

모든 경우의 수를 탐색한다? 8가지라면 경우의 수가 8! 개 존재한다.

///////////////////////////////////////////////////////////////////////////////////////////////////////////

처음에 k값을 갱신하지 않고 코드를 짜서 실패가 너무 많이 떳었다.

k -= i[1]으로 변경함으로서 어느정도 성공을 많이 하게 되었지만 여전히 실패가 많이 있다.

중간에 break를 통해 나올 수 있도록 코드를 짜야 겠다.

k값을 매 루프를 돌 동안에 처음값으로 초기화를 하지 않아 배열의 값이 첫번째 이후부터는 0만 나오게 되는 것을 해결했다.

던전의 수가 많지 않기 때문에 permutation 함수를 통해 모든 경우의 수에 대해서 count수를 계산하였으며,

최대 카운트 수를 반환하면 답이 된다.

루프 내에서의 조건은 던전 진입에 필요한 최소 피로도의 계산과, 던전 진입 후 피로도 값 계산만 잘 해주면 되는 문제였다.

from itertools import *

def solution(k, dungeons):

    permuts = list(permutations(dungeons))

    count_list = []

    for permut in permuts:

        count = 0
        fat = k

        for i in permut:

            if fat >= i[0] :
                fat -= i[1]
                count += 1

        count_list.append(count)

    return max(count_list)

print(solution(80, [[80,20],[50,40],[30,10]]))

//////////////////////////////////////////////////////////////////////////////////////////////////////////

다른 사람의 풀이를 확인해 보면, 우선도를 설정하여서 문제를 해결한 것을 알 수 있었다.

먼저 문턱 피로도의 경우 높을수록 우선도가 높았으며, 소모 필요도의 경우에는 낮을수록 우선도가 높았다.

따라서 우선도의 설정을 문턱 / 소모의 값을 통해 설정하여 루프를 돌 필요 없이 문제를 해결 한 듯 싶다.

우선도에 따라서 배열을 재배열을 해야 한다.

dungeons.sort(key = lambda x : x[0]/x[1])

를 통해서 우선순위에 따라 값들을 배열 하였다. 그리고 계산을 해보자.

def solution(k, dungeons):

    dungeons.sort(key = lambda x : (x[0]/x[1], x[0]), reverse=True)

    count = 0

    for dungeon in dungeons:

        if k >= dungeon[0]:

            k -= dungeon[1]

            count += 1

        else: break

    return count

print(solution(80, [[80,20],[50,40],[30,10]]))

위와 같은 코드를 이용하여 우선순위를 설정하고, 그로 정렬 한 뒤 던전을 도는 식으로 코드를 짜 봤는데,

중간에 생각하지 못한 테스트 케이스 가 있는 듯하다.

여기서 조건문을 통해 조건을 추가해주면, 위에서 내가 문제를 해결한 방식과 시간 복잡도의 차이가 거의 나지 않을 것 같아서

딱히 효율적인 방법인지는 모르겠다.

조금 더 생각을 해봐야 할 것 같다.















