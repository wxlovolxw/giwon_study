전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다.
전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다.

구조대 : 119
박준영 : 97 674 223
지영석 : 11 9552 4421
전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를
그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요.

제한 사항
phone_book의 길이는 1 이상 1,000,000 이하입니다.
각 전화번호의 길이는 1 이상 20 이하입니다.

입출력 예제
phone_book	                    return
[119, 97674223, 1195524421]	    false
[123,456,789]	                true
[12,123,1235,567,88]	        false

입출력 예 설명

입출력 예 #1
앞에서 설명한 예와 같습니다.

입출력 예 #2
한 번호가 다른 번호의 접두사인 경우가 없으므로, 답은 true입니다.

입출력 예 #3
첫 번째 전화번호, “12”가 두 번째 전화번호 “123”의 접두사입니다. 따라서 답은 false입니다.

/////////////////////////////////////////////////////////////////////////////////////////

phone_book 을 입력값으로 받아 특정 번호가 다른 번호의 접두사로서 존재하는지 아닌지를 반환해야한다.

-> 단순히 모든 문자열을 비교하는 것은 시간이 너무 오래 걸린다.
그래서 검색에 유리한 해시를 써야하는데, 결국에는 루프를 돌려야 하는것이 아닐까?
단순히 루프를 돌린다고 생각했을 때, 이중포문을 사용해야 한다.

모든 값들에 대해서 나머지 값들과의 비교를 하는 것은 너무 비효율적.

-> 딕셔너리와같은 해시를 어떻게 쓰는것이 좋을까
key와 value를 나누어 검색을 빠르게 한다. key값을 중복되지 않도록한다.
그렇다면 해당 value를 key로 사용해도 되는것인가? 오히려 더 비효율적인 것인가?

//////////////////////////////////////////////////////////////////////////////////////

def solution(phone_book):
    for i in phone_book:
        phone_book.sort()
        if list(map(lambda x: list(str(x))[:len(list(str(i)))], phone_book)).count(list(str(i))) >= 2:
            return False
        else:
            return True

-> 일단 두번의 루프를 통해서 모든 값들을 비교하는 코드를 짰지만 효율성이 매우 떨어지는 결과가 나왔다.

///////////////////////////////////////////////////////////////////////////////////////

def solution(phone_book):
    phone_book.sort()
    for i in phone_book:
        if list(map(lambda x: list(str(x))[:len(list(str(i)))], phone_book)).count(list(str(i))) >= 2:
            return False
        else: return True

-> sort를 실수로 루프 안에서 실행했다... 제대로 빼내고 실행을 하니 테스트와 효율성을 모두 통과하였다.

풀이 방법은 다음과 같다.

결과적으로 루프는 한번씩 돌아야 하는데, 그 루프가 도는것을 최소하 하기위해 오름차순으로 배열해준다.

그리고 앞의 값들부터 시작하여 해당 값과 일치하는 문자열이 있는지, 비교하는 시간을 줄이기 위해

해당 문자열과 길이가 같도록 길이를 자르고 나서 비교를 하였다.

그리고 본인을 포함해 count가 2이상이 되는경우 False를, 아니라면 True를 반환하도록 하였다.

////////////////////////////////////////////////////////////////////////////////////////////////////////

p2.startswith(p1) -> 을 통해 시작하는 문자열이 같은지 비교할수있다. 이런 상황이라면 매우 유용한 함수인것 같다.

값이 true/false로 반환

////////////////////////////////////////////////////////////////////////////////////////////////////////

완규코드

def solution(phone_book):
    answer = True
    sort_index = sorted(list(enumerate(map(lambda x: len(x),phone_book))),key = lambda x:x[1])
    sorted_pb = []
    for i in range(len(sort_index)):
        if i==0 :
            sorted_pb.append(phone_book[sort_index[0][0]])
            continue
        for j in range(len(sorted_pb)):
            if sorted_pb[j] == phone_book[sort_index[i][0]][:sort_index[j][1]]:
                return False
        sorted_pb.append(phone_book[sort_index[i][0]])

    return answer

---------------------------------------------------------------------------------------

테스트 케이스의 수정으로 인해 코드가 통과하지 못하게 되었다. 코드를 수정할 필요가 있다.
앞서 사용한 hash를 조금 더 활용하여 다시 코드를 짜보자.

연산을 줄이기 위해 비교하는 문자열의 길이로 모든 값들을 잘라서 보는 것이 좋을 것 같다.

dict에 key와 value를 저장할 때, key값을 hash의 합으로 해야 할 것같다.

-> 문제점은 해당 문자열의 원래 길이에 대한 정보가 필요한데, 이에 대한 정보를 구현하는 방법이 어렵다.

-> 접두사이기 때문에 어쨋든 처음부터의 문자열이 중요하므로 이를 잘 이용해 보자.

제일 짧은 문자열부터 확인하는게 맞다.

길이별로 정렬 시에는 sort(key='len')을 이용해 준다.

-> 각 성분들에 대해서 비교를 해주려면 이중포문이 꼭 필요하다.
-> 특정 숫자열 전체가 다른 숫자열의 접두사가 되어야 한다.

해당 숫자열보다 길이가 긴 대상들에 대해서만 확인해주면 된다. -> 연산횟수를 많이 줄일 수 있다.

-----------------------------------------------------------------------------------------

sort의 기본적인 성질에 따라, 기본적인 정렬 방식이 사전순이기 때문에
나열될 때 접두사가 될 가능성이 있는 문자는 바로 앞에 오게 된다.

따라서 바로 뒤에 있는 숫자에 이 숫자가 포함이 되는지만 확인해주면 된다.

def solution(phone_book):
    phone_book.sort()

    for i, num in enumerate(phone_book):

        length = len(num)

        try :
            if num == phone_book[i+1][:length] :

                return False

            else:
                return True
        except : IndexError

-> 수정을 했음에도 완전히 똑같은 결과가 나왔다. 정확성에서도 정확하지 않으면서 효율성도 떨어진다.

-> 처음부터 다시 생각해 봐야 할 것 같다.

------------------------------------------------------------------------------------------

배열했을 때, 앞뒤를 간격으로 접두어가 없는 경우?

1112 11123 1113 과 같은 배치라면 sort를 통해

1112 11123 1113이 배치될 것이다.

def solution(phone_book):
    phone_book.sort()
    result = 0

    for i, num in enumerate(phone_book):

        length = len(num)

        try :
            if num == phone_book[i+1][:length]:
                return False

        except : IndexError

    return True

-> 마지막에 return True를 해줘야 한다. 위의 코드에서는 for 문 안에 return True를 해줘서
뒤에 만족하는 값이 있음에도 True가 반환되는 문제가 발생하였다. 마지막에 return을 해줌으로서 해결 되었다.








