
정규 표현식

	복잡한 문자열을 처리할 때 사용하는 기법으로, 파이썬만의 고유 문법이 아니라 문자열을 처리		하는 모든 곳에서 사용된다. 간단히 줄여 "정규식"이라고도 한다.
	
	ex) 주민번호를 포함하고 있는 텍스트가 있다. 이 텍스트에 포함된 모든 주민등록번호의 뒷자리	를 * 문자로 변경해 보자.

		-> 정규식을 모른다면 아래와 같은 순서로 프로그램을 작성할 것이다.
		
		1) 전체 텍스트를 공백 문자로 나눈다.(split)
		2) 나뉜 단어가 주민등록번호 형식인지 조사한다.
		3) 단어가 주민번호 형식이라면 뒷자리를 * 로 변환한다.
		4) 나뉜 단어를 다시 조합한다.

		data = """
		park 800905-1049118	#line 1
		kim 700905-1059119	#line 2
		"""

		result = []	# 행을 기준으로 데이터를 리스트로 받아서 저장
		for line in data.split("\n") :	# 줄바뀜을 기준으로 행을 나눈다
			word_result = []	# 띄어쓰기를 기준으로 데이터를 리스트로 받아서 저장
			for word in line.split(" ") :	# 띄어쓰기를 기준으로 이름과 번호를 나눈다
				if len(word) == 14 and word[:6].isdigit() and word[7:].isdigit() :
					word = word[:6] + "-" + "*******"
				word_result.append(word)
			result.append(" ".join(word_result)) #word_result 사이에 띄어쓰기
		print("\n".join(result))	#word사이에 줄바뀜
				
		-> 정규식을 사용한다면

		import re

		data = """
		park 800905-1049118	#line 1
		kim 700905-1059119	#line 2
		"""
		
		pat = re.compile("(\d{6})[-]\d{7}")
		print(pat.sub("\g<1>-*******", data))

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

정규식 표현의 기초(메타 문자)

	정규 표현식에서 사용하는 메타문자에는 다음과 같은 것이 있다.(메타 문자란 원래 그 문자가 	가진 뜻이 아닌 특별한 용도로 사용하는 문자를 말한다.)

	ex) . ^ $ * + ? { } [ ] \ | ( )


	문자 클래스 [ ]

		문자 클래스로 만들어진 정규식은 "[ ] 사이의 문자들과 매치"라는 의미를 갖는다.

		-> 문자 클래스를 만드는 메타 문자인 [] 사이에는 어떤 문자도 들어갈 수 있다.

		ex) 정규 표현식이 [abc]라면 이 표현식의 의미는 "a,b,c 중 한 개의 문자와 매치"를 뜻		한다. 만약 문자열 "a", "before", "dude"가 정규식 [a,b,c]가 있다면 다음과 같이 매치		된다.

			"a"는 정규식과 일치하는 문자 "a"가 있으므로 매치
			"before"는 "b"가 있으므로 매치
			"dude"는 매치되지 않음.

		[] 안의 두 문자 사이에 하이픈(-)을 사용하면 두 문자 사이의 범위(from-to)를 의미한		다. 예를 들어 [a-c] 는 [abc]와 동일하고 [0-5]는 [012345]와 동일하다.

			[a-zA-Z] : 알파벳 모두
			[0-9] : 숫자

		문자 클래스([])안에는 어떤 문자나 메타 문자도 사용할 수 있지만 주의해야 할 메타 		문자가 있다. ^는 문자 클래스 안에서 반대(not)의 의미를 갖는다. [^0-9]라는 정규 표		현식은 숫자가 아닌 문자만 매치된다.

		* 자주 사용하는 문자 클래스

			\d : 숫자와 매치, [0-9]와 같은 표현식
			\D : 숫자가 아닌 것과 매치, [^0-9]와 동일
			\s : whitespace 문자와 매치, [ \t\n\r\f\v]와 동일(맨앞의 빈칸은 공백문			자(space)를 의미한다.
			\S : whitespace 문자가 아닌것과 매치, [^ \t\n\r\f\v]와 동일
			\w : 문자+숫자와 매치, [a-zA-Z0-9_]와 동일한 표현
			\W : 문자+숫자가 아닌문자와 매치, [^a-zA-Z0-9_]와 동일한 표현

			-> 대문자 표현식은 소문자 표현식과 반대의 의미이다.

	
	Dot(.)

		Dot(.) 메타 문자는 줄바꿈 문자인 \n을 제외한 모든 문자와 매치됨을 의미한다.

		*re.DOTALL 옵션을 주면 \n 문자와도 매치 된다.

		ex) a.b

		-> "a+모든문자+b" , a와 b라는 문자 사이에 어떤 문자가 들어가도 모두 매치가 된다		는 의미이다.

			"aab"는 가운데 문자 "a"가 모든 문자를 의미하는 .과 일치하므로 매치된다.
			"a0b"도 매치된다.
			"abc"는 "a"와 "b" 사이에 문자가 존재하지 않으므로 매치되지 않는다.
		
		ex) a[.]b

		-> a + Dot(.)문자 + b" : 문자열 "a.b"와 매치되고, "a0b"와는 매치 되지 않는다.

	반복 (*)

		ex) ca*t

		-> 이 정규식에는 반복을 의미하는 * 메타 문자가 사용되었다. 여기에 사용한 *는 * 		바로 앞에 존재하는 문자 a가 0부터 무한대로 반복될 수 있다는 의미이다.(2억개 정도		까지)	

			ct - "a"가 0번 반복되어 매치
			cat - "a"가 1번 반복되어 매치
			caaat - "a"가 3번 반복되어 매치

	반복 (+)

		*과 마찬가지로 +도 반복을 나타낸다. 다른점이라면 +는 1회 이상의 반복에 대해서 		매치한다.

		ex) ca+t

			ct - "a"가 1회 미만 반복되어 매치되지 않는다.
			cat - "a"가 1번 반복되어 매치
			caaat - "a"가 3번 반복되어 매치	

	반복({m,n}, ?)

		만약 반복회수에 제한을 두고 싶다면 {} 메타 문자를 사용해서 고정할 수 있다. 만약 		값을 생략한다면 m은 0, n은 무한(2억미만)이 된다.
		
		{1,}은 +와 같고, {0,}은 *와 같다.

		ex) ca{2}t

		-> a가 2번 반복 된 경우에 한하여 매치된다.

		ex) ca{2,5}t
		
		-> a가 2~5회 반복된 경우에 한하여 매치된다.
		
		ex) ab?c
	
		-> ?는 {0,1}와 같은 의미로 있어도 되고 없어도 된다는 의미이다.


	***** * 와 +, ? 메타 문자는 모두 {m,n}의 형태로 쓰는 것이 가능하지만 이해하기 간편한 형태인 	*, +, ?의 메타 문자를 사용하는 것이 좋다.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

정규 표현식을 지원하는 re 모듈

	파이썬은 정규 표현식을 지원하기 위해 re(regular expression) 모듈을 제공한다. re 모듈은 파	이썬을 설치할 때 자동으로 설치되는 기본 라이브러리로 사용 방법은 다음과 같다.

	import re

	p = re.compile('ab*')

	-> re.compile을 사용하여 정규표현식()로 쌓인 부분을 컴파일 한다. 컴파일 결과로 돌려주는 	객체 p를 사용하여 그 이후의 작업을 수행할 수 있다.

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////		
정규식을 이용한 문자열 검색

	컴파일된 패턴 객체를 사용하여 문자열 검색을 수행해 보자. 다음 4개의 메서드를 제공한다.

	match() : 문자열의 처음부터 정규식과 매치되는지 조사한다.
	search() : 문자열 전체를 검색하여 정규식과 매치되는지 조사한다.
	findall() : 정규식과 매치되는 모든 문자열을 리스트로 돌려준다.
	finditer() : 정규식과 매치되는 모든 문자열을 반복 가능한 객체로 돌려준다.

	-> match, search는 정규식과 매치될 때는 match 객체를 돌려주고, 매치되지 않을 때는 None	을 돌려준다.

	import re
	p = re.compile('[a-z]+')	# 소문자 알파벳이 1회이상 반복
		
	* match

		문자열의 처음부터 정규식과 매치되는지 조사한다. 위 패턴에 match 매서드를 수행		해보자.

		m = p.match("python")
		print(m)

		-> <_sre.SRE_Match object at 0x01F3F9F8>
		-> 문자열 "python"은 정규식 [a-z]+에 부합되므로 매치된다.

		m = p.match("3 python")
		print(m)
		
		-> None
		-> "3 python" 문자열은 처음에 나오는 문자가 소문자 알파벳이 아닌 숫자 3이므로 		None을 돌려준다.

		ex)
		p = re.compile(정규표현식)
		m = p.match( 'string goes here'  )
		if m :
			print('Match found: ', m.group())
		else :
			print('No match')


	* search
		
		m = p.search("python")
		print(m)
		
		-><_sre.SRE_Match object at 0x01F3FA68>
		
		m = p.search("3 python")
		print(m)
		
		-> <_sre.SRE_Match object at 0x01F3FA30>

		-> match는 문자열의 처음에 나오는 문자에 대해서 검색을 하는것이 아니라, 문자열 		전체에 대한 검색을 하기 때문에 3 이후의 문자열 python과 매치가 된다.

		* match 메서드와 search 메서드는 문자열의 처음부터 검색할지의 여부에 따라 다르		게 사용된다.

	* findall

		result = p.findall("Life is too short")
		print(result)
		-> ['Life', 'is', 'too', 'short']

		-> 문자열의 각 단어들에 대해서 각각 [a-z]+ 정규식과 매치해서 리스트로 돌려준다.

	* finditer

		result = p.finditer("Life is too short")
		print(result)
		
		-> <callable_iterator object at 0x01F5E390>

		for r in result : print(r)

		-> ...
		<_sre.SRE_Match object at 0x01F3F9F8>
		<_sre.SRE_Match object at 0x01F3FAD8>
		<_sre.SRE_Match object at 0x01F3FAA0>
		<_sre.SRE_Match object at 0x01F3F9F8>

		-> finditer은 findall과 동일하지만 그 결과로 반복가능한 객체를 돌려준다. 반복 가능		한 객체가 포함하는 각각의 요소는 match 객체이다.

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

match 객체의 메서드

	match 메서드와 search 메서드를 수행한 결과로 돌려준 match 객체에 대해 알아보자.

	- 어떤 문자열이 매치되었는가
	- 매치된 문자열의 인덱스는 어디서부터 어디까지인가

	-> match 객체의 메서드를 사용하면 해결 할 수 있다.

		group() : 매치된 문자열을 돌려준다.
		start() : 매치된 문자열의 시작 위치를 돌려준다.
		end() : 매치된 문자열의 끝 위치를 돌려준다.
		span() : 매치된 문자열의 (시작, 끝)에 해당하는 튜플을 돌려준다.

		m = p.match("python")
		m.group()
		-> 'python'

		m.start()
		-> 0
	
		m.end()
		-> 6

		m.span()
		-> (0,6)

	-> search 메서드를 사용했다면 다음과 같은 결과가 나온다.

		m = p.search("3 python")
		m.group()
		-> 'python'

		m.start()
		-> 2
	
		m.end()
		-> 8

		m.span()
		-> (2,8)

	***** re 모듈은 코드를 축약한 형태로서 사용할 수 있다.

		p = re.compile('[a-z]+')
		m = p.match("python")

		위의 코드를 다음과 같이 축약할 수 있다.

		m = re.match('[a-z]+', "python")

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

컴파일 옵션

	정규식을 컴파일할 때 다음 옵션을 사용할 수 있다.

	DOTALL(S) - .이 줄바꿈 문자를 포함하여 모든 문자와 매치할 수 있도록 한다.
	IGNORECASE(I) - 대소문자에 관계없이 매치할 수 있도록 한다.
	MULTILINE(M) - 여러줄과 매치할 수 있도록 한다. (^, $ 메타문자의 사용과 관계가 있는 옵션이		다.)
	VERBOSE(X) - VERBOSE 모드를 사용할 수 있도록 한다. (정규식을 보기 편하게 만들수 있고 주	석들을 사용할 수 있게 된다.)
























