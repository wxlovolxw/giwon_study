
	인터 프린터 -  한 줄씩 소스코드를 해석해서 그때그때 실행해 결과를 바로 확인 할 수 있		는 언어

	대화형

	숫자형의 타입은 따로 정해져 있지 않은가?

	-> 대소문자를 구분한다

	-> 두 줄 이상을 입력 할 때에는 :를 쓰고 다음줄로
	다음줄이 시작할 때에는 tab을 꼭 사용하여 줄 조절

	-> 사용자 지정 함수 def
		def 사용자 지정 함수명(변수)
			반환값

	-> 주석 다는 법 #, 세줄 이상인 경우는 """내용"""

///////////////////////////////////////////////////////////////////////////////////////////////////////////////

	숫자형

		정수형 (interger)
		실수형 (floating-point) - 소수점, 컴퓨터식 지수 표현 e,E를 사용

	사칙연산

	x^y -> x**y : x의 y제곱 형태

	나눗셈 후 나머지를 반환 : %
		ex) 7%3 -> 1

	나눗셈 후 몫을 반환 : //
		ex) 7/4 -> 1.75
		7//4 -> 1

	8진수와 16진수

		0o177 -> 숫자0 + 알파벳o

		0xABC -> 숫자0 + 알파벳x



///////////////////////////////////////////////////////////////////////////////////////////////////////////////

	문자열 자료형

	" ", ' ', """ """, ''' '''

	-> '를 사용하고 싶은 경우 -> ""를 사용하면 내부의 '라 기호로 인식되지 않는다.
				''를 사용하면 오류가 발생한다

	-> ""를 사용하고 싶은 경우 -> ''를 사용한다.

	-> 혹은 두가지 경우 모두 사용하고자 하는 '," 앞에 백슬래시 \를 사용하면 된다.

	-> 여러줄을 문자열에 대입하고 싶은 경우 \n을 사용한다.

* escape code

	미리 정의해 둔 문자의 조합
	주로 출력불을 보기 좋게 정렬하는 용도로 사용한다

	* \n - 문자열 안에서 줄을 바꿀 때 사용
	* \t - 문자열 사이에 탭 간격을 줄때
	* \\ - 문자 \를 사용
	* \' - 문자 '를 사용
	* \" - 문자 "를 사용

////////////////////////////////////////////////////////////////////////////////

문자열의 연산

	- 문자열 더해서 연결하기

	+ 를 이용해 문자열을 연결할 수 있다

	head = "Python"
	tail = " is fun!"
	head + tail
	-> 'Python is fun!'

	- 문자열에 상수를 곱하면 해당 문자열을 연속적으로 반복

	a = "python"
	a * 2
	-> ' pythonpython'

	- 문자열 길이 구하기 len()

	문자열 인덱싱과 슬라이싱

	-> 인덱싱 : 문자열의 각 문자마다 번호를 매긴다.(띄어쓰기 포함) 음수인 경우에는 뒤에서 부터의 숫자를 의미함

	a = "Life is too short, You need Pyton"          

 	-> 슬라이싱 : 문자열 내에서 한 문자만 뽑아내는 방법
	
	a[0:4] -> 끝번호에 해당하는 숫자는 포함하지 않기 때문에 a[0:3]을 하게 되면 Lif 만 호출된다.

	ex) a = "20010331Rainy"
	year = a[:4]
	day = a[4:8]
	weather = a[8:0]

* 잘못된 문자열 바꾸기

	Pithon -> Python

	a = "Pithon"
	a[1] = 'y' -> 오류 발생

	a[:1] + 'y' + a[2:]

* 문자열 포매팅 따라하기

	"I eat %d apples." % 3 -> 숫자 넣기

	number = 3
	"I eat %d apples." % number

	"I eat %s apples." % five -> 문자열 넣기

	number = 10
	day = "three"
	"I ate %d apples. so I was sick for %s days." (number, day)


	%s 문자열
	%c 문자1개
	%d 정수
	%f 부동소수

	"%10s" % 'hi" -> %10s는 전체길이 10개인 공백
	'          hi'

* format 함수

	"I eat {0} apples." .format(3)

	"I eat {0} apples." .format("five")

	number = 3
	"I eat {0} apples." .format(number)
	
	number = 10
	day = "three"
	"I ate {0} apples. so I was sick for {1} days." .format(number, day)
	-> 순서에 맞게 입력하면 인덱스 항목이 입력값으로 순서에 맞게 변한다.

	I ate {number} apples. so I was sick for {day} days." .format(number=10, day=3)
			
치환되는 문자열 정렬

	"{0:<10}" .format("hi")
	-> 왼쪽으로 hi가 정렬된 형태

	"{0:^10}" .format("hi")
	-> 오른쪽으로 hi가 정렬된 형태

	가운데 정렬은 :^를 사용

공백 채우기

	"{0:=^10}" .format("hi")
	-> hi를 가운데 정렬하고 나머지는 =로 채운다

	"{0:!<10}" .format("hi")

f 문자열 포매팅

	접두사 f를 이용해 f 문자열 포매팅 기능 사용 가능

	name = '홍길동'
	age = 30
	f'나의 이름은 {name}입니다. 나이는 {age}입니다.'
	-> '나의 이름은 홍길동 입니다. 나이는 30입니다.

	f'나는 내년이면 {age+1}살이 된다.'
	-> '나는 내년이면 31살이 된다.'

딕셔너리 - key와 value라는 것을 한쌍으로 갖는 자료형

	d = {'name' : '홍길동', 'age' : 30}
	f'나의 이름은 {d["name"]}입니다. 나이는 {d["age"]}입니다.'

	정렬방법
		왼쪽 - f'{''hi":<10}'
		오른쪽 :>
		가운데 :^

* 문자열 관련 함수들

	문자열 내의 문자 수 세기(count)
	
		a = "hobby"
		a.count('b')

		a내에서 문자 b의 갯수를 센다.

	위치 알려주기(find)

		a = "Python is the best choice"
		a.find('b')
		a.find('k') -> 없는경우 -1

	위치 알려주기2(index)

		a = "Life is too short"
		a.index('t')

	소문자 대문자로 바꾸기 - upper

	대문자를 소문자로 바꾸기 - lower

	왼쪽(오른쪽) 의 공백 지우기 - lstrip(rstrip)
	양쪽 - strip

	문자열 바꾸기 - replace

		a = "Life is too short"
		a.replace("Life", "Your leg")

	문자열 나누기 - split
		괄호 내의 문자 혹은 공백을 기준으로 나누어준다.

///////////////////////////////////////////////////////////////////////////////

리스트 -  숫자혹은 문자열의 모음

	리스트명 = [요소1, 요소2, 요소3, ...]

	비어있는 리스트 생성 -> a=list()

	ex) a = [1,2,3]
	a[0] -> 1
	a[-1] -> 3
	a[0] + a[2] -> 4

	a = [1, 2, 3, ['a', 'b', 'c']]
	a[3] -> ['a','b','c']
	a[-1][0] -> 'a'

	-> 슬라이싱 방법은 문자열의 슬라이싱과 같다.

	ex) a = [1, 2, 3, ['a', 'b', 'c'], 4, 5]
	a[3][:2]
	-> ['a', 'b']

	-> 리스트의 연산. +를 사용하면 단순히 리스트 내의 자료들이 추가된다.

	ex) a = [1, 2, 3]
	b = [4, 5, 6]
	a+b -> [1, 2, 3, 4, 5, 6]

	-> 리스트의 길이 구하기
	len(a)

	ex) 3hi를 입력하고 싶을때
	a = [1, 2, 3]
	a[2] + "hi" -> 오류 발생
	str(a[2]) + "hi" -> 숫자를 문자열로 바꾼후에 연결해줘야 한다

	-> 리스트 내의 값 수정하기

	a = [1, 2, 3]
	a[2] = 4
	a -> [1, 2, 4] 로 세번째 리스트의 값이 변경됨.

	-> del 함수 사용해 리스트 요소 삭제하기
	del 함수는 파이썬 내의 모든 객체를 삭제할 수 있다.

	ex) a = [1, 2, 3]
	del a[1]
	a -> [1, 3]
	-> 두번째 리스트의 값만 삭제 되는 것이 아니라 두번째 리스트 자체가 삭제된다.

	-> 리스트에 요소 추가(append)
	a = [1, 2, 3]
	a.append(4)
	a -> [1, 2, 3, 4]
	
	리스트 안에는 어떠한 자료형도 추가할 수 있다.

	-> 리스트 내의 요소들을 순서대로 정렬
	리스트명.sort() -> 괄호 내에 정렬하는 방식?

	디폴트가 오름차순. ()안에 reverse=True를 하면 내림차순

	-> 요소들을 역순으로 뒤집기
	리스트명.reverse
	리스트 내의 요소들이 역순으로 뒤집는다. 
	만약 리스트 내의 요소들의 순서를 그대로 하고 값들만 역순으로 반환하고 싶다면 리스트의 요	소들을 받는 새로운 변수를 선언한 뒤 그 변수를 역순으로 반환한다.

	-> 값들을 반환할 대에도 print(a.reverse)와 같은 형태로 하는 것이 아니라 b = a.reverse로 선	언 한 뒤에 print(b)를 해주는 것이 좋다.

	-> 위치 반환(index)
	리스트명.index(문자) -> 문자의 위치값을 반환

	-> 요소 삽입(insert)
	리스트명.insert(a,b) -> a번째 위치에 b를 삽입

	-> 리스트에서 요소 제거(remove)
	리스트명.remove(제거할값)

	-> 요소 끄집어내기(pop)
	맨 마지막 요소를 끄집어 내고 그 요소를 삭제한다
	
	a = [1, 2, 3]
	a.pop() -> 3
	a -> [1, 2]

	a = [1, 2, 3]
	a.pop(1) -> 2 (2번째 요소를 추출)
	a -> [1, 3]
	
	-> 리스트에 포함된 요소 x의 갯수 세기(count)
	리스트명.count()

	-> 리스트 확장하기 (extend)
	리스트명.extend(리스트)

	a.extend([4, 5])는 a + [4, 5]와 일치한다.

////////////////////////////////////////////////////////////////////////////////

튜플은 리스트와 거의 비슷하지만 다른점이 몇가지 있다.

t1 = ()
t2 = (1, )
t3 = (1, 2, 3)
t4 = 1, 2, 3
t5 = ('a', 'b', ('ab', 'cd'))

- 리스트는 []로 둘러쌓여 있지만 튜플은 ()로 둘러싼다.
- 리스트는 그 값의 생성, 삭제, 수정이 가능하지만 튜플은 그 값을 바꿀 수 없다.
- 튜플은 하나의 값 만을 가져도 요소 뒤에 콤마를 반드시 붙여야 한다.
- 괄호를 생략해도 무방하다.

-> 변화시킬수 있는가의 여부가 가장 큰 차이를 가져온다. 역할이 비슷하지만 구별해서 사용하는 것이 유리하다.

////////////////////////////////////////////////////////////////////////////////

딕셔너리 -> 대응관계를 나타내는 자료형. 배열 혹은 해시 라고 한다.

	key와 value를 한 쌍으로 갖는 자료형.
	리스트, 튜플처럼 순차적인 해당 요구값을 구하는 것이 아니라 key를 통해 해당 value를 구한다.

	{key1:value1, key2:value2, key3:value3, ...}
	-> key에는 변하지 않는 값을 사용하고 value에는 변하는 값과 변하지 않는 값을 모두 사용할 수 있다.

	ex) di = {'name':'pey', 'phone':'01199993323', 'birth':'1118'}

	key 	value
	name	pey
	phone	01199993323
	birth	1118

	-> value에 리스트도 넣을 수 있다.

- 딕셔너리 쌍 추가 삭제하기

	a = {1:'a'}
	a[2] = 'b'
	a -> {1:'a', 2:'b'}
	a[name] = 'pey'
	a -> {1:'a', 2:'b', name:'pey'}

	del a[1]
	a -> {2:'b', 'name':'pey', 3:[1,2,3]}

-> key의 value를 얻는 방법
	딕셔너리의 변수이름[key]

	ex) grade = {'pey':10, 'julliet':99}
	grade['pey'] -> 10
	grade['julliet'] -> 99

- 중복되는 key를 사용한 경우 하나의 key를 제외하고는 무시된다.
- key에는 리스트를 사용할 수가 없다.

	-> key의 리스트 만들기 : keys
	a = {'name':'pey', 'phone':'01199993233', 'birth':'1118'}
	a.keys() -> dict_keys(['name', 'phone', 'birth'])

	dict_keys 객체는 리스트와 비슷하지만 리스트의 함수는 사용할 수 없다. append, insert, pop, 	remove, sort

	-> value의 리스트 : values
	a.values
	
	-> key와 value의 쌍 얻기 : items
	a.items

	-> 쌍 모두 지우기 : clear
	a.clear
	*딕셔너리 안의 모든 요소를 삭제한다.

	-> key로 value 얻기
	a.get('name') 과 a['name'] 은 같은 value를 돌려준다.
	만약에 존재하지 않는 key에 대해서 value를 반환한다면 get은 none을 반환하고 []는 오류를 발생시킨다.

	-> 미리 정해진 디폴트 값 대신 가져오기
	get(x, '디폴트 값')	

	ex) a.get('foo', 'bar')
	-> 딕셔너리에 foo라는 key가 존재하지 않을때 bar를 반환

	-> 해당 key가 딕셔너리 안에 존재하는지 조사하기 : in
	'name' in a -> true or false

////////////////////////////////////////////////////////////////////////////////

집합 자료형 : set

	s1 = set([1,2,3])
	s1 -> {1,2,3}

	set의 괄호 안에 리스트를 입력하거나 문자열을 입력할 수도 있다.

	s2 = set("Hello")
	s2 -> {'e', 'H', 'l', 'o'} 

	-> 중복을 허용하지 않는다. 순서가 없다(unordered)
	순서가 없기때문에 인덱싱을 통해 자료형을 얻을수 없다.

	-> 인덱싱으로 접근하려면 리스트나 튜플로 변환 해야 한다.
	ex) s1 = set([1,2,3])
	
	* 리스트로 변환
	l1 = list(s1)
	l1 -> [1,2,3]
	l1[0] -> 1
	or
	* 튜플로 변환
	t1 = tuple(s1)
	t1 -> (1,2,3)
	t1[0] -> 1

- 교집합, 합집합, 차집합

	- 교집합 & or intersection
	s1 & s2
	s1.intersection(s2)

	- 합집합 | or union
	s1 | s2
	s1.union(s2)

	- 차집합 - or difference
	s1 - s2
	s1.differernce(s2)

- 값 추가 및 제거

	1개의 값 추가 : add
	s1.add(값)

	여러개의 값 한번에 추가 : update
	s1.update([값1, 값2, 값3, ...])

	특정 값 제거하기 : remove
	s1.remove(제거하고 싶은값)

////////////////////////////////////////////////////////////////////////////////

불(bool) 자료형
	참과 거짓으로 나타내는 자료형
	True, Fales 와 같이 첫 문자를 항상 대문자로 써야 한다.

	a = True
	b = False
	와 같이 변수를 지정하면
	두 변수의 자료형이 bool로 지정된다

	type(a) -> class 'bool'
	type(b) -> class 'bool'

	-> 조건문의 반환값으로도 사용된다.
	ex) 1 == 1 -> True
	2 > 1 -> True

	- 자료형의 참과 거짓
	문자열 "", 리스트 [], 튜플 (), 딕셔너리 등의 값이 비어있으면 거짓, 비어있지 않으면 참
	숫자에는 값이 0이 될때 거짓, 아닐때 참
	None은 거짓을 뜻한다.

	ex) while -> 조건문이 참인 동안에 조건문 안의 문장을 반복해서 수행

	a = [1, 2, 3, 4]
	while a:
		print(a.pop())	-> pop함수는 리스트 a의 마지막 요소를 끄집어 낸다.
				끄집어낸 값은 반환하고 그 값을 리스트에서 제거한다.
	-> 4
	3
	2
	1
	* 마지막 값을 계속 꺼내게 되면 모든 값이 사라지게 되면 거짓이 되어 더이상 while문을 돌리	지 않게 된다.

	* bool함수를 통한 자료형의 참 거짓 식별
	bool('Python') -> True
	bool('') -> False

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	C와 자바의 경우는 변수의 자료형을 지정해 줘야하는 반면 스스로 판단하여 지정한다.
	
	a = [1, 2, 3]
	-> [1, 2, 3]의 값을 갖는 리스트 자료형이 자동으로 메모리에 생성되고, 변수 a는 리스트가 저장	된 메모리의 주소를 가리킨다.

	a의 주소는 id(a)를 통해 확인 할 수 있다.

	리스트의 복사는 다음과 같이 할 수 있다.
	b = a
	-> b와 a는 완전히 동일하다. [1, 2, 3] 리스트를 참조하는 변수가 a 1개에서 a, b 2로 늘었다는 
	차이밖에 없다.
	id(a)의 주소와 id(b)의 주소도 일치한다.

	a is b -> True
	
	* 이 상태에서 a의 리스트를 변경하게 된다면 b 리스트의 값도 변하게 된다.

* 변수 b를 생성할 때 a 변수의 값을 가져오면서 a와는 다른 주소를 가리키도록 만드는 방법

	1) [:]의 이용
		리스트 전체를 가리키는 [:]를 복사해서 사용하는 방법
		
		ex) a = [1, 2, 3]
		b = a[:]		-> b = a와 다르게 그 값만을 받아와서 사용한다.
		
	2) copy  모듈의 이용
		
		ex) from copy import copy
		b = copy(a) 	-> b = a[:]와 같다

		-> 첫줄은 copy함수를 사용하기 위해 쓰는것.

		b is a -> False

	* 변수를 만드는 여러가지 방법

		a, b = ('python', 'life')
		(a, b) = 'python', 'life'
		
		-> 튜플은 괄호를 생략해도 무방하다.

		[a, b] = ['python', 'life']

		-> 리스트로 변수를 만들 수도 있다.

		a = b = 'python'
	
		-> 여러 개의 변수에 같은 값을 대입할 수도 있다.

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

if문 -> 조건을 판단한 후 그 상황에 맞게 수행을 하는데 사용

	ex)money = True

	if money :
		print("택시를 타고 가라")
	else : 
		print("걸어 가라")

	-> if 조건문 :
		수행할 문장 (수행할 문장에서는 항상 들여쓰기를 해야한다. - tab or space 4개)
	else : 
		수행할 문장

	-> 조건문

		비교 연산자. <, >, ==, !=, >=, <=
		and, or, not

		x in s, x not in s (x라는 요소가 리스트, 튜플, 문자열 내에 존재하는지)

		pass -> 조건문에서 아무 일도 하지 않게 설정
	
	* elif - if와 else만으로는 판단하기 어려운 경우.

		ex) 주머니에 돈이 있다면 택시를 타고, 돈이 없지만 카드가 있다면 택시를 타고 둘다 		없다면 걸어가라

		pocket = ['money', 'card']

		if 'money' or 'card' in pocket :
			print("택시를 타고가라")
		else :
			print("걸어가라")	
		
		pocket = ['money', 'card']

		if 'money' in pocket : 
			print("택시를 타고가라")
		elif card : 
			print("택시를 타고가라")
		else : 
			print("걸어가라")

	-> 조건부 표현식

		if score >= 60 :
			message = "success"
		else :
			message = "failure"

		를 다음과 같이 표현할 수 있다.
		message = "success" if score >= 60 else "failure"
		조건문이 참인 경우 if 조건문 else 조건문이 거짓인 경우

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

while문 -> 문장을 반복해서 사용해야 하는 경우. 반복문이라고도 부른다.

	while 조건문 :
		수행할 문장

	-> 조건문이 참인 동안에 while문 아래의 문장이 반복해서 수행된다.

	ex) treeHit = 0
	while treeHit < 10 :
		treeHit = treeHit +1
		print("나무를 %d번 찍었습니다." % treeHit)
		if treeHit == 10:
			print("나무가 넘어갑니다.")
			
	ex) promt = """
	1. Add
	2. Del
	3. List
	4. Quit

	Enter number : """

	number = 0
	while number != 4 :
		print(prompt)
		number = int(input())

	* while문 강제로 빠져나가기

	coffee = 10
	money = 300
	while money : 
		print("돈을 받았으니 커피를 줍니다.")
		coffee = coffee -1
		print("남은 커피의 양은 %d개 입니다." % coffee)
		if coffee == 0 :
			print("커피가 다 떨어졌습니다. 판매를 중지합니다.")
			break

	-> s가 문자열 d가 정수를 받는 포매팅

	coffee = 10
	while True :
		money = int(input("돈을 넣어 주세요 : "))
		if money == 300 :
			print("커피를 줍니다.")
			coffee = coffee -1
		elif money > 300 :
			print("거스름돈 %d를 주고 커피를 줍니다." % (money - 300))
			coffee = coffee -1
		else :
			print("돈을 다시 돌려주고 커피를 주지 않습니다.")
			print("남은 커피의 양은 %d개 입니다." % coffee)
		if coffee == 0 :
			print("커피가 다 떨어졌습니다. 판매를 중지 합니다.")
			break
	
	-> while문의 맨 처음으로 돌아가기 : continue
		while문을 빠져나가지 않고 while문의 맨 처음(조건문)으로 다시 돌아가고 싶은 경우
	
		a = 0
		while a < 10 :
			a = a + 1
			if a % 2 == 0 : continue
			print(a)

		-> 1에서부터 10까지 홀수만 출력한다.
		짝수면 print를 수행하지 않고 처음으로 돌아가 홀수일 경우에만 print 한다

		a = 0
		while a < 10 :
			a = a + 1
			if a % 2 != 0 :
				print(a)
			else :
				pass
		-> 위의 결과와 같다.

	-> 무한 루프
		while True : 
			수행문

		-> while문의 조건이 항상 참이므로 while문이 무한히 수행된다.

		Ctrl + c를 통해 빠져나갈 수 있다.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

for문 - while문과 비슷한 반복문이지만 유용하고 문장 구조가 알기 쉬운 장점이 있다. 파이썬의 직관적인 특징을 가장 잘 대변해 준다.

	for 변수 in (리스트, 튜플, 문자열) : 
		수행할 문장

	변수에 리스트들의 인덱스를 차례로 받아와 그 값들에 대해서 수행을 한다.

	ex) test_list = ['one', 'two', 'three']
	for i in test_list :
		print(i)

	ex) a = [(1, 2), (3, 4), (5, 6)]
	for (first, last) in a :
		print(first + last)

	ex) marks = [90, 25, 67, 45, 80]
	
	number = 0
	for mark in marks : 
		number = number + 1
		if mark >= 60 :
			print("%d번 학생은 합격입니다." % number)
		else :
			print("%d번 학생은 불합격입니다." % number)

	-> for문과 continue : for문 안에서도 continue를 만나면 반복문의 맨 처음으로 이동하게 된다.
	
	ex) marks = [90, 25, 67, 45, 80]

	number = 0
	for mark in marks :
		number = number + 1
		if mark < 60 :
			continue
		print("%d번 학생 축하합니다. 합격입니다. " % number)

	-> range 함수 : 지정된 숫자 범위를 갖는 객체를 만들어준다.
	
		ex) a = range(10) : 0부터 10미만의 숫자를 포함하는 객체 끝 숫자는 포함되지 않는		다
		a = range(1,11) : 1부터 11미만

		ex) add = 0
		for i in range(1,11) : 
			add = add + i
		print(add)

		ex) marks = [90, 25, 67, 45, 80]
		for number in range(len(marks)) : 
			if marks[number] < 60 :
				continue
			print("%d번 학생 축하합니다. 합격입니다." %(number+1)) 
		-> len 함수는 리스트 안의 요소의 갯수를 반환. 따라서 len(marks)는 5가 될것이고, 			range함수에 0에서부터 4까지의 값이 대입된다.

		ex) for i in range(2,10) : 
			for j in range(1,10) : 
				print(i*j, end = "  ")
			print(' ' )
		->end=""와 같이 매개변수 end를 넣은 이유는 해당 결과값을 출력할 때 다음줄로 넘		어가지 않고 그 줄에서 게속 출력을 하기 위함. 마지막 for문의 마지막에 print(' ')를 		사용한 이유는 자음 줄을 구분하기 위해 출력하는 문장

	-> 리스트 내포 사용하기 : 직관적인 프로그램을 만들기 위해 사용

		ex) a = [1, 2, 3, 4]
		result = []
		for num in a :
			result.append(num*3)

		print(result)

		-> 빈 리스트 result를 만들고, a 리스트의 값에 3배에 해당하는 값들을 result 리스트		에 넣는다. (리스트 내포를 사용하지 않은 방법)

		a = [1, 2, 3, 4]
		result = [num*3 for num in a]
		print(result)
	
		-> 리스트 내포를 이용하여 바로 a 리스트 내의 값들에 대해서 연산을 수행하였다.

		a = [1, 2, 3, 4]
		result = [num*3 for num in a if num % 2 == 0]
		print(result)

		[표현식 for 항목 in 반복가능객체 if 조건문]
		반복문을 2개 이상 사용하는 것도 가능하다
		-> for 항목1 in 반복객체1 if 조건문1
		for 항목2 in 반복객체2 if 조건문2 ...

		ex) result = [x*y for x in range(2,10)
				for y in range(1,10)]
		print(result)
