문제 설명
받을 수 있는 상품 번호가 적혀있는 상품권을 사람들이 각자 하나씩 가지고 있습니다. 사람들은 각자 받고 싶은 상품이 있는데,
자신이 가지고 있는 상품권의 번호가 자신이 받고 싶은 상품의 번호가 아니라면 다른 사람과 교환할 수 있습니다.
이때, 원하지 않는 상품을 받는 사람 수를 최소로 해야 합니다.

예를 들어 상품권을 가진 사람이 5명이고, 첫 번째 사람부터 가지고 있는 상품권에 적힌 번호가 [4, 5, 3, 2, 1],
각 사람이 받고 싶어 하는 상품 번호가 순서대로 [2, 4, 4, 5, 1]라고 하겠습니다.

이 경우 다섯 번째 사람은 가지고 있는 상품권에 적힌 번호(1번)가 받고 싶은 상품 번호(1번)와 일치하기 때문에 다른 사람과 교환하지 않아도 됩니다.

또, 첫 번째, 두 번째, 네 번째 사람의 경우 아래와 같이 상품권을 교환하면 각자 받고 싶은 상품의 번호가 적힌 상품권을 가질 수 있습니다.

첫 번째 사람과 네 번째 사람의 번호를 교환합니다. (4번 ↔ 2번)
다시, 두 번째 사람과 네 번째 사람의 번호를 교환합니다. (5번 ↔ 4번)
이제 각 사람이 가지고 있는 상품권에 적힌 번호는 아래와 같습니다.

[2, 4, 3, 5, 1]
세 번째 사람은 4번 상품을 받고 싶지만, 더 교환할 사람이 없습니다. 따라서 원하는 상품을 받을 수 없는 사람은 최소 1명이 됩니다.

사람들이 가지고 있는 상품권에 적힌 번호가 순서대로 들어있는 배열 gift_cards와 각 사람이 받고 싶어 하는 상품 번호가 순서대로 들어있는 배열 wants가 매개변수로 주어질 때,
원하는 상품을 받지 못하는 사람의 최솟값을 return 하도록 solution 함수를 완성해주세요.

제한 사항
gift_cards와 wants의 길이는 1 이상 100,000 이하이며, 두 배열의 길이는 항상 같습니다.
gift_cards와 wants의 원소는 1 이상 100,000 이하인 자연수입니다.
모든 상품은 여분없이 각 번호가 적힌 상품권 개수만큼 준비되어 있다고 가정합니다.

입출력 예

gift_cards	    wants	        result
[4, 5, 3, 2, 1]	[2, 4, 4, 5, 1]	1
[5, 4, 5, 4, 5]	[1, 2, 3, 5, 4]	3

입출력 예 설명
입출력 예 #1
문제의 설명과 같습니다.

입출력 예 #2
네 번째, 다섯 번째 사람만 교환을 통해 자신이 원하는 상품을 받을 수 있으며, 나머지 세 명은 원하는 상품을 받을 수 없습니다.

---------------------------------------------------------------------------------------------------------

결국에는 교환을 통해 자리바꿈을 해줄 수 있으므로, 애초에 존재하지 않는 값들을 세주면된다.

wants에 들어있는 성분은 2, 4, 4, 5, 1로
1-1, 2-1, 4-4, 5-1 성분의 종류는 4개

gift_cards에 들어있는 성분은 1, 2, 3, 4, 5로
1-1, 2-1, 3-1, 4-1, 5-1 성분의 종류는 5가지가 된다.

wants의 성분들과 gift_cards의 성분들을 모두 튜플이나 딕셔너리의 형태로 만들어야 한다.

그리고 wants의 첫번째 성분에 대해서, gift에도 같은 값이 존재한다면 그 값을 카운트 하는 방식으로 해야 한다.

wants_tup = list(set(list(map(lambda x : (x, wants.count(x), wants))))
gift_tup = list(set(list(map(lambda x : (x, gift_cards.count(x), gift_cards))))

고려해야 하는 사항은 다음과 같다.

wants에 대해서 해당 번호를 원하는 사람이 3명 일때,    -> i[1]
gift_cards가 0이라면 그대로 3(3-0)명을 다 더하고,    gift_cards.count(i[0])
1이라면 2(3-1)을 더하고, gift_cards가 3보다 크다면 0 을 더하면 된다.

---------------------------------------------------------------------------------------------------------

def solution(gift_cards,wants) :

    wants_tup = list(set(list(map(lambda x: (x, wants.count(x)), wants))))

    count = 0

    for i in wants_tup :

        count += max(i[1] - gift_cards.count(i[0]), 0)

    return count

print(solution([4, 5, 3, 2, 1],[2, 4, 4, 5, 1]))

-> 일단 간단하게 짜보았는데 다른 테스트 코드들로 확인해 봐야 할 것 같다.










////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

문제 설명
로봇을 이용하여 여러 종류의 완제품을 만드는 공장을 운영하려고 합니다. 로봇 한 대는 부품 한 종류만 처리할 수 있으며,
완제품의 종류에 따라 필요한 부품이 다를 수 있습니다. 이때, 로봇 r대로 최대한 다양한 완제품을 만들려 합니다.

예를 들어, 각 완제품을 만들 때 다음과 같은 부품이 필요하고, 살 수 있는 로봇은 최대 두 대라고 가정하겠습니다(번호는 0번부터 시작합니다).

완제품 번호	필요한 부품 번호
0	        0
1	        0, 1
2	        0, 1
3	        0, 2
4	        0, 1
5	        1, 2

두 로봇을 이용해 완제품을 만드는 경우는 모두 다음과 같습니다.

구매할 첫 번째 로봇	    구매할 두 번째 로봇	    만들 수 있는 완제품
부품 0을 처리하는 로봇	부품 1을 처리하는 로봇	0, 1, 2, 4번 완제품
부품 0을 처리하는 로봇	부품 2를 처리하는 로봇	0, 3번 완제품
부품 1을 처리하는 로봇	부품 2를 처리하는 로봇	5번 완제품

따라서, 최대한 다양한 완제품을 만들려면 부품 0을 처리하는 로봇과 부품 1을 처리하는 로봇을 구매해야 합니다.

완제품을 만드는 데 필요한 부품의 정보 needs와 최대로 구매 가능한 로봇 수 r이 매개변수로 주어질 때,
최대 몇 종류의 완제품을 만들 수 있는지 return 하도록 solution 함수를 완성해 주세요.

제한사항

needs의 세로(행) 길이는 1 이상 1,000 이하입니다.
세로(행) 길이는 만들 수 있는 완제품의 개수를 나타냅니다.
행 번호는 완제품의 번호를 의미하며, 0번부터 시작합니다(0행 → 0번 완제품, 1행 → 1번 완제품 ...).
needs의 가로(열) 길이는 1 이상 15 이하입니다.
열 번호는 부품 번호를 의미하며, 0번부터 시작합니다.
needs의 모든 원소는 0 또는 1 입니다.
needs[x][y] 값이 1이면 x번 물건을 만드는데 y번 부품이 필요하다 의미입니다.
needs[x][y] 값이 0이면 x번 물건을 만드는데 y번 부품이 필요 없다는 의미입니다.
번호가 가로(열) 길이 이상인 부품은 모두 필요 없는 것으로 가정하면 됩니다.
예를 들어, 가로(열) 길이가 3인 경우 0번 ~ 2번 부품에 대한 정보가 주어지며, 3보다 큰 번호의 부품은 모두 필요 없는 것으로 가정하면 됩니다.
r은 1 이상 needs의 가로(열) 길이 이하인 자연수입니다.

입출력 예

needs	                                                                r	result
[ [ 1, 0, 0 ], [1, 1, 0], [1, 1, 0], [1, 0, 1], [1, 1, 0], [0, 1, 1] ]	2	4

입출력 예 설명
입출력 예 #1

앞서 설명한 예시와 같습니다.

---------------------------------------------------------------------------------------------------------

입력이 needs와 r로 주어지게 된다.

needs는 리스트의 리스트로 주어지게 된다.

needs[i]의 각 요소의 순서는 완제품의 번호순이며

needs[i]의 성분 needs[i][j]는 해당 성분이 필요한지 아닌지를 알려주는 값이다. 1이면 필요, 0이면 필요X

따라서 needs[i]의 길이 len(needs[i])는 총 재료의 갯수가 된다.

이때 다른 입력값 r에 의해 살수있는 성분수가 정해지게 되고, 만들수 있는 완제품의 수를 result로 반환하면 된다.

예시를 보면

needs = [ [ 1, 0, 0 ], [1, 1, 0], [1, 1, 0], [1, 0, 1], [1, 1, 0], [0, 1, 1] ]
r = 2

두개의 재료로 만들수 있는 최대 갯수. 일단 1의 갯수, 재료의 갯수가 r개를 넘지 않는 성분들에 대해서 계산하는 게 좋을 것 같다.

needs_comp = [x for x in needs if x.sum() <= r]

-> 일의 위치를 받는 튜플을 생성.

(0), (0,1), (0,1), (0,2), (0,1), (1,2)와 같은 형태로. 그리고 그 수를 count? -> 너무 비효율 적인 것 같다.

-> 모든 조합에 대해서 계산하는 것은 더욱이 비효율적.

만약 재료의 수가 많아지고 r값이 커지게 된다면 조합을 구하기가 어렵다. -> 1의 개수가 많은 재료를 우선적으로 보는 것이 좋은가?

성분 0은 총 5개, 1은 4개, 2는 2개의 1을 가지고 있다. -> 공통으로 가지고 있는 완제품이 많이 없다면?

-----------------------------------------------------------------------------------------------------------------

-> 전체 값에서 해당 재료가 필요없는 경우를 빼주면 된다.

ex) 모든 재료의 수 중에서 해당 재료가 필요없는 경우를 count 하고, count의 총합이 min이 되도록 해서 빼주면
만들수 있는 완제품의 수가 최대가 된다.

needs = [ [ 1, 0, 0 ], [1, 1, 0], [1, 1, 0], [1, 0, 1], [1, 1, 0], [0, 1, 1] ]
r = 2

-> 총 재료수는 3개이고, 2개를 선택할 것이므로 필요없는 재료는 1가지.
이 1가지의 필요없는 재료가 들어가는 완제품은 2개 이므로,
전체 완제품의 수 - 2번재료가 들어가는 완제품의 수 = 4 가 되는 알고리즘을 짜면 될 것 같다.

전체 완제품 수 -> len(needs)
2번 재료가 들어가는(재료가 없어 만들어지질 완제품. 최소가 되어야 함) -> ???

    필요없는 재료의 수 -> len(needs[0]) - r








////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

문제 설명
1부터 n까지 번호가 하나씩 붙어있는 n개의 역이 철로로 연결되어 있습니다. 철로는 양방향 통행이 가능하며, 임의의 두 역을 직접 연결하는 철로는 최대 하나입니다.
또, 서로 다른 두 역 사이의 이동 경로는 딱 한 가지며, 임의의 두 역 사이에 이동 불가능한 경우는 없습니다.

출발역과 종착역 사이를 왕복하는 열차를 운행하려 합니다. 출발역은 1번 역이며, 전체 역 중 한 곳을 종착역으로 정해야 합니다.
단, 열차가 출발역에서 종착역까지 갈 때 모든 역을 방문할 필요는 없으며, 같은 역을 두 번 이상 방문하면 안 됩니다.

종착역을 정하기 위해 각 역의 일일 이용객 수를 조사했습니다. 이때, 열차가 방문하는 역의 일일 이용객 수의 합이 최대가 되도록 종착역을 지정하면 됩니다.
만약 일일 이용객 수의 합이 최대가 되는 역이 여러개라면, 그 중 번호가 큰 역을 선택하면 됩니다.

전체 역의 개수 n, 1번부터 n번 역까지 일일 이용객 수 passenger, 역 사이의 철로 연결 정보 train이 매개변수로 주어질 때,
종착역으로 지정할 역 번호와 그때의 이용객 수 합을 순서대로 배열에 담아 return 하도록 solution 함수를 완성해주세요.

제한사항

n은 2 이상 100,000 이하인 자연수입니다.
passenger의 길이는 n입니다.
passenger의 원소는 1 이상 10,000 이하인 자연수입니다.
passenger[i]는 i + 1번 역의 일일 이용객 수 입니다.
train의 세로(행) 길이는 n - 1 입니다.
train의 가로(열) 길이는 2입니다.
train의 원소는 [A, B] 형태입니다.
A, B는 철로가 연결하는 두 역의 번호입니다.
A, B는 1 이상 n 이하인 자연수이며, A와 B가 같은 경우는 없습니다.
같은 철로에 대한 정보가 중복해서 들어있지 않습니다.

입출력 예

n	passenger	    train	                            result
6	[1,1,1,1,1,1]	[[1,2],[1,3],[1,4],[3,5],[3,6]]	    [6,3]
4	[2,1,2,2]	    [[1,2],[1,3],[2,4]]	                [4,5]
5	[1,1,2,3,4]	    [[1,2],[1,3],[1,4],[1,5]]	        [5,5]

입출력 예 설명
입출력 예 #1

train_2.png

5번 역을 종착역으로 정하면 열차는 1번 역 → 3번 역 → 5번 역 → 3번 역 → 1번 역 → ... 과 같이 움직입니다. 1번, 3번, 5번 역의 일일 이용객 수의 합은 3명입니다.
6번 역을 종착역으로 정하면 열차는 1번 역 → 3번 역 → 6번 역 → 3번 역 → 1번 역 → ... 과 같이 움직입니다. 1번, 3번, 6번 역의 일일 이용객 수의 합은 3명입니다.
일일 이용객 수의 합이 최대인 경우가 여러 개라면 그중 번호가 큰 역을 선택해야 합니다. 따라서 6번 역을 종착역으로 정합니다.

입출력 예 #2

4번 역을 종착역으로 정하면 열차는 1번 역 → 2번 역 → 4번 역 → 2번 역 → 1번 역 → ... 과 같이 움직입니다. 세 역의 일일 이용객 수의 합은 5명이 되고, 이때가 최대입니다.

입출력 예 #3

5번 역을 종착역으로 정하면 열차는 1번 역 → 5번 역 → 1번 역 → ... 과 같이 움직입니다. 1번, 5번 역의 일일 이용객 수의 합은 5명이고, 이때가 최대입니다.

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

















